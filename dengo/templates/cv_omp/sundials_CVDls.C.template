{% block solver_comment_header %}
/* THIS FILE HAS BEEN AUTO-GENERATED.  DO NOT EDIT. */

/* This is C++ code to read HDF5 files for
   reaction rates, cooling rates, and initial
   conditions for the chemical network defined
   by the user.  In addition, this contains
   code for calculating temperature from the
   gas energy and computing the RHS and the
   Jacobian of the system of equations which
   will be fed into the solver.
*/
{% endblock %}

#include "{{solver_name}}_solver.h"

///////////////////////////////////////////////////////////////////////////////
/////////// Setup the reaction, cooling rate data table ///////////////////////
///////////////////////////////////////////////////////////////////////////////
{{solver_name}}_data *{{solver_name}}_setup_data( const char *FileLocation, int *NumberOfFields, char ***FieldNames)
{

    //-----------------------------------------------------
    // Function : {{solver_name}}_setup_data
    // Description: Initialize a data object that stores the reaction/ cooling rate data
    //-----------------------------------------------------

    int i, n;

    {{solver_name}}_data *data = ({{solver_name}}_data *) malloc(sizeof({{solver_name}}_data));

    // point the module to look for {{solver_name}}_tables.h5
    data->dengo_data_file = FileLocation;

    /* allocate space for the scale related pieces */

    // Number of cells to be solved in a batch
    data->nstrip = MAX_NCELLS;
    /*initialize temperature so it wont crash*/
    for ( i = 0; i < MAX_NCELLS; i++ ){
        for( n = 0; n < NTHREADS; n++ ){
            data->Ts[n][i]    = 1000.0;
            data->logTs[n][i] = log(1000.0);
        }
    }

    /* Temperature-related pieces */
    data->bounds[0] = {{ network.T_bounds[0] }};
    data->bounds[1] = {{ network.T_bounds[1] }};
    data->nbins = {{ network.T | length }} - 1;
    data->dbin = (log(data->bounds[1]) - log(data->bounds[0])) / data->nbins;
    data->idbin = 1.0L / data->dbin;

    /* Redshift-related pieces */
    data->z_bounds[0] = {{ network.z_bounds[0] }};
    data->z_bounds[1] = {{ network.z_bounds[1] }};
    data->n_zbins = {{ network.z | length }} - 1;
    data->d_zbin = (log(data->z_bounds[1] + 1.0) - log(data->z_bounds[0] + 1.0)) / data->n_zbins;
    data->id_zbin = 1.0L / data->d_zbin;

    {{ solver_name }}_read_rate_tables(data);
    //fprintf(stderr, "Successfully read in rate tables.\n");

    {{ solver_name }}_read_cooling_tables(data);
    //fprintf(stderr, "Successfully read in cooling rate tables.\n");

    {{ solver_name }}_read_gamma(data);
    //fprintf(stderr, "Successfully read in gamma tables. \n");

    if (FieldNames != NULL && NumberOfFields != NULL) {
        NumberOfFields[0] = {{network.required_species | length}};
        FieldNames[0] = new char*[{{ network.required_species | length }}];
        i = 0;
        {%- for s in network.required_species | sort %}
        FieldNames[0][i++] = strdup("{{s.name}}");
        {% endfor %}
    }

    data->dengo_data_file = NULL;

    return data;

}

{% block read_tables %}
void {{ solver_name }}_read_rate_tables({{solver_name}}_data *data)
{
    const char * filedir;
    if (data->dengo_data_file != NULL){
        filedir =  data->dengo_data_file;
    } else{
        filedir = "{{solver_name}}_tables.h5";
    }

    hid_t file_id = H5Fopen( filedir , H5F_ACC_RDONLY, H5P_DEFAULT);
    /* Allocate the correct number of rate tables */

    {%- for name, rate in network.reactions | dictsort %}
    H5LTread_dataset_double(file_id, "/{{ name }}", data->r_{{name}});
    {%- endfor %}

    H5Fclose(file_id);
}


void {{ solver_name }}_read_cooling_tables({{solver_name}}_data *data)
{

    const char * filedir;
    if (data->dengo_data_file != NULL){
        filedir =  data->dengo_data_file;
    } else{
        filedir = "{{solver_name}}_tables.h5";
    }
    hid_t file_id = H5Fopen( filedir , H5F_ACC_RDONLY, H5P_DEFAULT);
    /* Allocate the correct number of rate tables */

    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    H5LTread_dataset_double(file_id, "/{{name}}_{{name2}}",
                            data->c_{{name}}_{{name2}});
    {%- endfor %}
    {%- endfor %}

    H5Fclose(file_id);
}

void {{ solver_name }}_read_gamma({{solver_name}}_data *data)
{

    const char * filedir;
    if (data->dengo_data_file != NULL){
        filedir =  data->dengo_data_file;
    } else{
        filedir = "{{solver_name}}_tables.h5";
    }

    hid_t file_id = H5Fopen( filedir , H5F_ACC_RDONLY, H5P_DEFAULT);
    /* Allocate the correct number of rate tables */


    {%- for sp in network.interpolate_gamma_species | sort %}
    H5LTread_dataset_double(file_id, "/gamma{{sp.name}}",
                            data->g_gamma{{sp.name}} );
    H5LTread_dataset_double(file_id, "/dgamma{{sp.name}}_dT",
                            data->g_dgamma{{sp.name}}_dT );
    {% endfor %}

    H5Fclose(file_id);

}
{% endblock %} {# read_tables #}

{% block interpolate_rates %}
/*
   This setup may be different than the user may anticipate, as a result
   of the lockstep timestep we use for a pencil beam through the grid.
   As such, it accepts the number of things to interpolate and makes
   assumptions about the sizes of the rates.
*/

/* This also requires no templating other than for the solver name...*/
void {{ solver_name }}_interpolate_rates({{ solver_name }}_data *data,
                    int nstrip)
{
    int i, bin_id, zbin_id;
    double lb, t1, t2;
    double lbz, z1, z2, Tdef, zdef;
    int no_photo = 0;
    lb = log(data->bounds[0]);
    lbz = log(data->z_bounds[0] + 1.0);


    i = 0;
    #ifdef _OPENMP
    int threadID = omp_get_thread_num();
    #else
    int threadID = 0;
    #endif

    for ( i = 0; i < nstrip; i++ ){
        data->bin_id[threadID][i] = bin_id = (int) (data->idbin * (data->logTs[threadID][i] - lb));
        if (data->bin_id[threadID][i] <= 0) {
            data->bin_id[threadID][i] = 0;
        } else if (data->bin_id[threadID][i] >= data->nbins) {
            data->bin_id[threadID][i] = data->nbins - 1;
        }
        t1 = (lb + (bin_id    ) * data->dbin);
        t2 = (lb + (bin_id + 1) * data->dbin);
        data->Tdef[threadID][i] = (data->logTs[threadID][i] - t1)/(t2 - t1);
        data->dT[threadID][i] = (t2 - t1);
        /*fprintf(stderr, "INTERP: %d, bin_id = %d, dT = % 0.16g, T = % 0.16g, logT = % 0.16g\n",
                i, data->bin_id[i], data->dT[i], data->Ts[i],
                data->logTs[i]);*/

    if ((data->current_z >= data->z_bounds[0]) && (data->current_z < data->z_bounds[1])) {
        zbin_id = (int) (data->id_zbin * (log(data->current_z + 1.0) - lbz));
        if (zbin_id <= 0) {
            zbin_id = 0;
        } else if (zbin_id >= data->n_zbins) {
            zbin_id = data->n_zbins - 1;
        }
        z1 = (lbz + (zbin_id    ) * data->d_zbin);
        z2 = (lbz + (zbin_id + 1) * data->d_zbin);
        data->zdef = (log(data->current_z + 1.0) - z1)/(z2 - z1);
        data->dz = (exp(z2) - exp(z1)); //note: given this, we don't have to divide rate of change by z
    } else {
        no_photo = 1;
    }
    }

    zdef   = data->zdef;

    {% for name, rate in network.reactions | dictsort %}
    {%- if 'pi' not in name %}

    for ( i = 0; i < nstrip; i++ ){
        bin_id = data->bin_id[threadID][i];
        Tdef   = data->Tdef[threadID][i];
        data->rs_{{name}}[threadID][i] = data->r_{{name}}[bin_id] +
            Tdef * (data->r_{{name}}[bin_id+1] - data->r_{{name}}[bin_id]);
        data->drs_{{name}}[threadID][i] = (data->r_{{name}}[bin_id+1] - data->r_{{name}}[bin_id]);
        data->drs_{{name}}[threadID][i] /= data->dT[threadID][i];
        data->drs_{{name}}[threadID][i] *= data->invTs[threadID][i];
    }
    {% else %}
    for ( i = 0; i < nstrip; i++ ){
        if (no_photo) {
            data->rs_{{name}}[threadID][i] = 0.0;
            data->drs_{{name}}[threadID][i] = 0.0;
        } else {
        data->rs_{{name}}[threadID][i] = data->r_{{name}}[zbin_id] +
            zdef * (data->r_{{name}}[zbin_id+1] - data->r_{{name}}[zbin_id]);
        }
    }
    {% endif -%}
    {% endfor %}

    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    {%- if 'ph' not in name %}
    for ( i = 0; i < nstrip; i++ ){
        bin_id = data->bin_id[threadID][i];
        Tdef   = data->Tdef[threadID][i];
        data->cs_{{name}}_{{name2}}[threadID][i] = data->c_{{name}}_{{name2}}[bin_id] +
            Tdef * (data->c_{{name}}_{{name2}}[bin_id+1] - data->c_{{name}}_{{name2}}[bin_id]);
        data->dcs_{{name}}_{{name2}}[threadID][i] = (data->c_{{name}}_{{name2}}[bin_id+1] - data->c_{{name}}_{{name2}}[bin_id]);
        data->dcs_{{name}}_{{name2}}[threadID][i] /= data->dT[threadID][i];
        data->dcs_{{name}}_{{name2}}[threadID][i] *= data->invTs[threadID][i];
    }
    {%- else %}
    for ( i = 0; i < nstrip; i++){
        if (no_photo) {
            data->cs_{{name}}_{{name2}}[threadID][i] = 0.0;
            data->dcs_{{name}}_{{name2}}[threadID][i] = 0.0;
        } else {
            data->cs_{{name}}_{{name2}}[threadID][i] = data->c_{{name}}_{{name2}}[zbin_id] +
                zdef * (data->c_{{name}}_{{name2}}[zbin_id+1] - data->c_{{name}}_{{name2}}[zbin_id]);
        }
    }
    {%- endif -%}
    {% endfor %}
    {% endfor %}

}
{% endblock %} {# interpolate_rates #}

{% block interpolate_gamma %}
void {{ solver_name }}_interpolate_gamma({{ solver_name }}_data *data,
                    int i)
{

    /*
     * find the bin_id for the given temperature
     * update dT for i_th strip
     */

    int bin_id, zbin_id;
    double lb, t1, t2;
    double lbz, z1, z2;
    int no_photo = 0;
    lb = log(data->bounds[0]);
    lbz = log(data->z_bounds[0] + 1.0);

    #ifdef _OPENMP
    int threadID = omp_get_thread_num();
    #else
    int threadID = 0;
    #endif

    data->bin_id[threadID][i] = bin_id = (int) (data->idbin * (data->logTs[threadID][i] - lb));
    if (data->bin_id[threadID][i] <= 0) {
        data->bin_id[threadID][i] = 0;
    } else if (data->bin_id[threadID][i] >= data->nbins) {
        data->bin_id[threadID][i] = data->nbins - 1;
    }
    t1 = (lb + (bin_id    ) * data->dbin);
    t2 = (lb + (bin_id + 1) * data->dbin);
    data->Tdef[threadID][i] = (data->logTs[threadID][i] - t1)/(t2 - t1);
    data->dT[threadID][i] = (t2 - t1);

    {% for sp in network.interpolate_gamma_species%}
    data->gamma{{sp.name}}[threadID][i] = data->g_gamma{{sp.name}}[bin_id] +
        data->Tdef[threadID][i] * (data->g_gamma{{sp.name}}[bin_id+1] - data->g_gamma{{sp.name}}[bin_id]);
    data->dgamma{{sp.name}}_dT[threadID][i] = data->g_dgamma{{sp.name}}_dT[bin_id] +
        data->Tdef[threadID][i] * (data->g_dgamma{{sp.name}}_dT[bin_id+1]
        - data->g_dgamma{{sp.name}}_dT[bin_id]);
    {% endfor %}

    }

{% endblock interpolate_gamma%}


///////////////////////////////////////////////////////////////////////////////
/////////////////// Main Evolution Routines            ////////////////////////
///////////////////////////////////////////////////////////////////////////////
{% block entry_point %}
int {{solver_name}}_main(int argc, char** argv )
{
    //-----------------------------------------------------
    // Function : {{solver_name}}_main
    // Description: this will look for initial condition files from the CLI,
    //              evolve the ODE system to dtf specified from the CLI, (if not it's set to freefall time),
    //              and write the result to {{solver_name}}_solution.h5 if output file name is not specified
    // Parameter:   argv[1]   : initial condition file name (in hdf5 format)
    //              argv[2]   : output file name (in hdf5 format)
    //              argv[3]   : desired final time reached by solver (in seconds)
    //
    // Note:        Units of initial conditions/ output
    //              Baryons: mass density in a.m.u * cm^-3 ( 1mH = 1.00794 amu )
    //              de     : number density of electrons in cm^-3
    //              ge     : internal energy per mass density of the cell (erg / g )
    //-----------------------------------------------------
    {{ solver_name }}_data *data = {{solver_name}}_setup_data(NULL, NULL, NULL);

    /* Initial conditions */
    hid_t file_id;
    if (argc < 2){
    file_id = H5Fopen("{{ solver_name }}_initial_conditions.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
    if (file_id < 0) {fprintf(stderr, "Failed to open "
        "{{ solver_name }}_initial_conditions.h5 so dying.\n");
        return(1);}
    } else {
        file_id = H5Fopen( argv[1], H5F_ACC_RDONLY, H5P_DEFAULT);
        if (file_id < 0) {fprintf(stderr, "Failed to open  your initial_conditions file so dying.\n");
        return(1);}


    }

    /* Allocate the correct number of cells */
    hsize_t dims; /* We have flat versus number of species */

    /* Check gas energy to get the number of cells */
    fprintf(stderr, "Getting dimensionality from {{ network.energy_term.name }}:\n");
    herr_t status = H5LTget_dataset_info(file_id, "/{{ network.energy_term.name }}", &dims, NULL, NULL);
    if(status == -1) {
        fprintf(stderr, "Error opening initial conditions file.\n");
        return 1;
    }
    fprintf(stderr, "  ncells = % 3i\n", (int) dims);
    data->ncells = dims;

    int N = {{network.required_species | length}};

    double *atol, *rtol;
    atol = (double *) malloc(N * dims * sizeof(double));
    rtol = (double *) malloc(N * dims * sizeof(double));

    double *tics = (double *) malloc(dims * sizeof(double));
    double *ics = (double *) malloc(dims * N * sizeof(double));
    double *input = (double *) malloc(dims * N * sizeof(double));
    double *temp  = (double *) malloc(dims * sizeof(double) );

    unsigned int i = 0, j;
    {% for s in network.required_species | sort %}
    fprintf(stderr, "Reading I.C. for /{{ s.name }}\n");
    H5LTread_dataset_double(file_id, "/{{ s.name }}", tics);
    for (j = 0; j < dims; j++) {
        ics[j * N + i] = tics[j];
        atol[j * N + i] = tics[j] * 1e-09;
        rtol[j * N + i] = 1e-09;
        if(j==0) {
            fprintf(stderr, "{{s.name}}[0] = %0.3g, atol => % 0.16g\n",
                    tics[j], atol[j]);
        }
    }
    i++;
    {% endfor %}

    double *density = (double *) malloc(dims *sizeof(double) );
    H5LTread_dataset_double(file_id, "/density", density);

    H5Fclose(file_id);

    double dtf = {{ network.stop_time }};
    // if the output time is specified,
    // it overrides the freefall time
    if (argc > 3){
        dtf = atof( argv[3] );
    }

    double dt = -1.0;
    double z = -1.0;
    for (i = 0; i < dims * N; i++) input[i] = ics[i];
    double ttot;
    int flag = dengo_evolve_{{solver_name}}(dtf, dt, z, input, rtol, atol, dims, data, temp);
    if (flag > 0){
        fprintf(stderr, "solver failed, Time reached by the solver: %0.5g \n", dt);
    }

    /* Write results to HDF5 file */

    if (argc < 3){
        file_id = H5Fcreate("{{ solver_name }}_solution.h5", H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
    } else{
        file_id = H5Fcreate( argv[2], H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
    }

    hsize_t dimsarr[1];
    dimsarr[0] = dims;
    i = 0;
    {% for s in network.required_species | sort %}
    double {{ s.name }}[dims];
    for (j = 0; j < dims; j++) {
        {{ s.name }}[j] = input[j * N + i];
    }
    fprintf(stderr, "Writing solution for /{{ s.name }}\n");
    H5LTmake_dataset_double(file_id, "/{{ s.name }}", 1, dimsarr, {{ s.name }});
    i++;
    {% endfor %}


    H5LTmake_dataset_double(file_id, "/T", 1, dimsarr, temp);

    double time[1];
    time[0] = ttot;
    double timestep[1];
    timestep[0] = dt;
    H5LTset_attribute_double(file_id, "/", "time", time, 1);
    H5LTset_attribute_double(file_id, "/", "timestep", timestep, 1);
    H5Fclose(file_id);

    free(temp);
    free(tics);
    free(ics);
    free(data);
    free(rtol);
    free(atol);
    free(input);
    free(density);

    return 0;
}
{% endblock %} {# entry_point #}

{% block main_evolution %}

int dengo_evolve_{{solver_name}} (double dtf, double &dt, double z, double *input,
            double *rtol, double *atol, unsigned long dims, {{solver_name}}_data *data, double *temp_array ){

    //-----------------------------------------------------
    // Function     : dengo_evolve_{{solver_name}}
    // Description  : Main ODE solver function in dengo

    // Parameter    :   dtf     : Desired time to be reached by the solver
    //                  dt      : Pointer to the actual time reached by the solver
    //                  z       : Current redshift
    //                  input   : Array to store the initial value of each species,
    //                            it will be updated with the value at time dt
    //                  rtol    : relative tolerance required for convergenece in each internal CVODE timesteps
    //                  atol    : absolute tolerance required for convergence in each interanl CVODE timesteps
    //                  dims    : dimension of the input array, i.e. no. of species * no. of cells
    //                  data    : {{solver_name}}_data object that relay the reaction/cooling rates, and normalizations
    //                  temp_array: temperature of each cell by the end of the evolution
    //
    //-----------------------------------------------------
    unsigned long i, j;
    hid_t file_id;
    /* fprintf(stderr, "  ncells = % 3i\n", (int) dims); */
    int N = {{network.ode_species | length}};

    data->reltol = rtol[0];

    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}

    double floor_value = data->floor_value;
    for (i = 0; i < dims*N; i++) input[i] = fmax(floor_value, input[i]);

    // when partial equilibrium solver is used
    // the equilibrium abundance is passed through the temp_array
    double *equil_array = &temp_array[dims];

    // TODO:
    // Need to consider the cases where
    // the incoming array assumes some equilibrium species,
    // - should first calculate temperature, then rates
    // - then equilibrium species
    // - then electron conservation
    // calculate_equilibrium_abundance(data, input, dims, 0, dims, equil_array);
    // ensure_electron_consistency(input, equil_array, dims, N);

    rhs_f f = calculate_rhs_{{solver_name}};

    #ifndef CVSPILS
    #ifdef  CVKLU
    jac_f jf = calculate_sparse_jacobian_{{solver_name}};
    #else
    jac_f jf = calculate_jacobian_{{solver_name}};
    #endif
    #endif

    #ifdef CVSPILS
    jac_f jf = calculate_JacTimesVec_{{solver_name}};
    #endif

    if (dt < 0) dt = dtf / 1e0;
    data->current_z = z;
    int niter = 0;
    int siter = 0;


    // Initialize a CVODE object, memory spaces
    // and attach rhs, jac to them
    int flag;
    double reltol = rtol[0];
    void *cvode_mem;
    int MAX_ITERATION = 10;
    double mh = 1.66054e-24;
    int nstrip = data->nstrip;

    // inputs are now grouped into a batch of nstrip
    // and send into the CVode solver
    //
    // ntimes: the number of times the CVode solver will be called
    // v_size: the size of the input vector for the solver
    //       : v_size = N * nstrip
    // v_size_res: leftover strip that doesn't fit into a v_size batch
    // N     : Number of species

    int v_size      = N * nstrip;
    int nstrip_res  = dims % nstrip;
    int v_size_res  = N * nstrip_res;
    unsigned long ntimes      = dims / nstrip;

    SUNLinearSolver LS;
    SUNMatrix A;
    N_Vector y_vec, abstol;

    y_vec = NULL;
    LS = NULL;
    A  = NULL;

    double *yvec_ptr;
    double *atol_ptr;

    // these objects should be initialize once !!
    // in each separate thread!!
    double *ttot = (double *) malloc( (ntimes + 1)* sizeof(double));
    int d;
    int sum;
    int NSPARSE = {{network.get_sparse_matrix_component(return_type="nsparse")}}; // no. of sparse jacobian compoents

    int threadID;
    SUNContext sunctx;

    // this routine is also called from the cythonized routine too
    // where MAX_NCELLS > input strip length
    // to avoid error message, we will catch it here
    if (ntimes > 0){

    #pragma omp parallel private (A, LS, cvode_mem, threadID, y_vec, abstol) num_threads(NTHREADS)
    {
    SUNContext_Create(NULL, &sunctx);

    y_vec  = N_VNew_Serial(v_size, sunctx);
    abstol = N_VNew_Serial(v_size, sunctx);

    yvec_ptr = N_VGetArrayPointer(y_vec);
    atol_ptr = N_VGetArrayPointer(abstol);

    // Need to be initialized before feeding into A, LS
    for (i = 0; i < v_size; i++) {
            yvec_ptr[i]   = 1.0;
            atol_ptr[i]   = reltol;
    }

    #ifdef CVKLU
    A         = SUNSparseMatrix      ( v_size, v_size, nstrip * NSPARSE, CSR_MAT, sunctx);
    LS        = SUNLinSol_KLU( y_vec, A, sunctx);
    #else
    A         = SUNDenseMatrix      ( v_size, v_size );
    LS        = SUNLinSol_DenseLinearSolver( y_vec, A, sunctx);
    #endif

    cvode_mem = setup_cvode_solver  ( f, jf, v_size , data, LS, A, y_vec, reltol, abstol, sunctx);

    // d: d th path going into the solver
    #pragma omp for private (sum, i, d, siter, threadID) schedule(static, 1)
    for (int d = 0; d < ntimes; d++){
        #ifdef _OPENMP
        threadID = omp_get_thread_num();
        #else
        threadID = 0;
        #endif
        ttot[d] = evolve_in_batches( cvode_mem, y_vec, abstol, reltol, input, v_size, d, d*v_size, MAX_ITERATION, dtf, data );

        // re-calculate temperature at the final output
        // updated in the data->Ts[threadID]
        {{solver_name}}_calculate_temperature(data, &input[d*v_size], nstrip, N);

        // fprintf(stderr, "%d th strip from thread %d = %0.5g\n", d, threadID, ttot[d]);
        if (ttot[d] < dtf){
            fprintf(stderr, "FAILED FROM thread %d at ttot[%d] = %0.5g \n", threadID, d, ttot[d]);
        }

        for ( i = 0; i < nstrip; i ++){
            temp_array[ d * nstrip + i ] = data->Ts[threadID][i];
        }
    calculate_equilibrium_abundance(data, &input[d*v_size], nstrip, d, dims, equil_array);

    {%- if network.enforce_conservation %}
    // not compatible yet with equilibrium species
    // ensure_species_conservation(&input[d*v_size], &data->mdensity[threadID][0], equil_array, data, nstrip, d, dims, N);
    {%- endif %}

    } // for d dims loop

    CVodeFree(&cvode_mem);
    SUNLinSolFree(LS);
    SUNMatDestroy(A);
    SUNContext_Free(&sunctx);
    #ifdef _OPENMP
    N_VDestroy(y_vec);
    N_VDestroy(abstol);
    #endif
    }
    } // if (ntimes > 0)

    if ( v_size_res > 0 ){
        #ifdef _OPENMP
        threadID = omp_get_thread_num();
        #else
        threadID = 0;
        #endif

        data->nstrip = nstrip_res;
        d = ntimes;

        SUNContext_Create(NULL, &sunctx);

        y_vec  = N_VNew_Serial( v_size_res, sunctx );
        abstol = N_VNew_Serial( v_size_res, sunctx );

        yvec_ptr = N_VGetArrayPointer(y_vec);
        atol_ptr = N_VGetArrayPointer(abstol);

        for (i = 0; i < v_size_res; i++) {
            yvec_ptr[i]   = 1.0;
            atol_ptr[i]   = reltol;
        }

        #ifdef CVKLU
        A  = SUNSparseMatrix(v_size_res, v_size_res, nstrip_res * NSPARSE, CSR_MAT, sunctx);
        LS = SUNLinSol_KLU(y_vec,A, sunctx);
        #else
        A  = SUNDenseMatrix(v_size_res, v_size_res);
        LS = SUNLinSol_DenseLinearSolver(y_vec, A, sunctx);
        #endif

        cvode_mem = setup_cvode_solver( f, jf, v_size_res, data, LS, A, y_vec, reltol, abstol, sunctx);
        ttot[d] = evolve_in_batches(cvode_mem, y_vec, abstol, reltol, input, v_size_res, d, d * v_size,  MAX_ITERATION, dtf, data);
        {{solver_name}}_calculate_temperature(data, &input[d*v_size], nstrip_res, N);
        for ( i = 0; i < nstrip_res; i ++){
            temp_array[ d * nstrip + i ] = data->Ts[threadID][i];
        }


        calculate_equilibrium_abundance(data, &input[d*v_size], nstrip_res, d, dims, equil_array);

        {%- if network.enforce_conservation %}
        // not compatible yet with equilibrium species
        //ensure_species_conservation(&input[d*v_size], &data->mdensity[threadID][0], equil_array, data, nstrip_res, d, dims, N);
        {%- endif %}
        //fprintf(stderr, "%d th strip = %0.5g\n", d, ttot[d]);

        // free all unused memory;
        CVodeFree(&cvode_mem);
        SUNLinSolFree(LS);
        SUNMatDestroy(A);
        N_VDestroy(y_vec);
        N_VDestroy(abstol);
        SUNContext_Free(&sunctx);
    } else{
      ttot[ntimes] = dtf;
    }

    // inputs are in `number density`
    {%- if network.enforce_conservation %}
    ensure_electron_consistency(input, equil_array, dims, N);
    {%- endif %}

    {%-  if not network.input_is_number %}
    for (i = 0; i < dims; i++) {
      j = i * N;
      {%- for species in network.ode_species | sort %}
      {%-if species.name != "ge" %}
      {{species.name}} = input[j];
      input[j] *= {{species.weight}}; // {{species.name}}
      {%-endif%}
      j++;
      {%-endfor%}
    }
    {%- endif %}

    double dt_final = dtf;

    for (int d = 0; d < (ntimes + 1); d++){
        if (ttot[d] < dt_final) dt_final = ttot[d];
    }

    // fprintf(stderr, "Fraction of completion (dt (%0.3g) / dtf (%0.3g)): %0.3g\n", dt, dt_final, dt_final/dtf);
    free(ttot);

    dt = dt_final;
    if (dt_final < dtf) return 1;
    return 0;

}
{% endblock %} {# main_evolution #}


{% block evolve_in_batches %}
double evolve_in_batches( void * cvode_mem, N_Vector y_vec, N_Vector abstol,
                          double reltol, double *input, int v_size, int d, int start_idx,
                          int MAX_ITERATION, double dtf, {{solver_name}}_data *data ){
    // Function   :     evolve_in_batches
    // Description:     this would evolve the ODE system in bataches of size v_size
    //                  and return the final time reached by the solver
    //
    // Parameter  :     cvode_mem   : CVODE memory object
    //                  y_vec           : Array to store/relay the data to the CVODE solver
    //                  abstol          : Array of absolute tolerance for each internal timestep
    //                  reltol          : Relative tolerance requested for each internal timestep
    //                  input           : Array to store the input number density/ energy of the species
    //                  v_size          : Size of the ODE system, i.e. No. of Species * No. of Strips/cells
    //                  d               : Batch count
    //                  start_idx       : Index to the first element from "input" for the current batch
    //                  MAX_ITERATION   : Maximum Call/retry to the CVODE solver
    //                  dtf             : Desired final output time
    //                  data            : {{solver_name}}_data object that stores rate/ temperature/ scale data
    // Return    :      ttot            : final time reached by the solver

    int i, siter, flag;
    double dt, ttot;
    double y[v_size];
    int nstrip = data->nstrip;

    #ifdef _OPENMP
    int threadID = omp_get_thread_num();
    #else
    int threadID = 0;
    #endif

    // access the array pointer of sundials vector object
    double *yvec_ptr = N_VGetArrayPointer(y_vec);
    double *atol_ptr = N_VGetArrayPointer(abstol);

    // by default: scale the input array
    #ifdef SCALE_INPUT
    double *scale = data->scale[threadID];
    double *inv_scale = data->inv_scale[threadID];
    for (i = 0; i < v_size; i++){
        scale[i]      = input[ start_idx + i];
        inv_scale[i]  = 1.0 / scale[i];
        yvec_ptr[i]   = 1.0;
        atol_ptr[i]   = reltol*reltol; //atol_ptr[i]*inv_scale[i];
    }
    setting_up_extra_variables(data, data->scale[threadID], nstrip );
    #else
    for (i = 0; i < v_size; i++){
        yvec_ptr[i]   = input[ start_idx + i];
        atol_ptr[i]   = reltol*reltol*yvec_ptr[i]; //atol_ptr[i]*inv_scale[i];
    }
    setting_up_extra_variables(data, yvec_ptr, nstrip );
    #endif

    // initialize a dt for the solver
    dt = dtf;
    ttot = 0.0;
    siter = 0;

    while (ttot < dtf) {
        // fprintf(stderr, "%d th strip: %d iterations, time: %0.5g\n", d, siter, ttot );
        flag = cvode_solver( cvode_mem, y, v_size , &dt, data, y_vec, reltol, abstol);

        for (i = 0; i < v_size; i++) {
            if (y[i] < 0) {
            // this catches negatives values smaller than the abstol
            // and replaces them
            // need to check the convergence of this approach
            if (y[i] + atol_ptr[i] > 0 ){
                y[i] = atol_ptr[i];
            } else{
                fprintf(stderr, "negative \n");
            flag = 1;
                    break;
	    }
            }
        }

        if (flag < 1){
            // flag = 0 => success
            // we reset the scale of each component
            // with the solution returned by the solver
            #ifdef SCALE_INPUT
            for (i = 0; i < v_size ; i++){
                yvec_ptr[i]   = 1.0;
        	//atol_ptr[i]   = fmin(reltol, atol_ptr[i]*inv_scale[i]);
                scale[i]     = y[i] * scale[i];
                inv_scale[i] = 1.0 /  scale[i];
            }
            #else
            for (i = 0; i < v_size ; i++){
                yvec_ptr[i]   = y[i];
            }
            #endif
            ttot += dt;
            dt = DMIN(dt * 2.0, dtf - ttot);
        } else{
            dt /= 2.0;
            dt = DMIN(dt , dtf - ttot);
        }
            if (siter == MAX_ITERATION) break;
            siter++;
    } // while loop for each strip

    // copy the results back to the input array
    // regardless the SCALE_INPUT
    // the returned array is still in number density
    // i.e. not scaled
    #ifdef SCALE_INPUT
    for (i = 0; i < v_size; i++){
        input[ start_idx + i] = scale[i];
    }
    #else
    for (i = 0; i < v_size; i++){
        input[ start_idx + i] = y[i];
    }
    #endif


    return ttot;
}
{% endblock evolve_in_batches%}

///////////////////////////////////////////////////////////////////////////////
//////////// Evaluate Temperature /////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

{% block calculate_temperature %}
int {{ solver_name }}_calculate_temperature({{ solver_name }}_data *data,
                        double *input, int nstrip, int nchem)
{
    int i, j;
    double density, T, Tnew;
    double kb = 1.3806504e-16; // Boltzmann constant [erg/K]
    double mh = 1.66054e-24;
    double gamma = 5.e0/3.e0;
    double _gamma_m1 = 1.0 / (gamma - 1);

    double dge_dT;

    {%- if 'H2_1' in network.species_list() %}
    double gammaH2 = 7.e0/5.e0; // Should be a function of temperature
    double dge;
    {%- for sp in network.interpolate_gamma_species | sort %}
    double gamma{{sp.name}};
    double dgamma{{sp.name}}_dT;
    double _gamma{{sp.name}}_m1;
    {%- endfor %}

    double Tdiff = 1.0;
    double reltol = data->reltol;
    int MAX_T_ITERATION = 100;
    int count = 0;
    {%- endif %}

    /* Calculate total density */
    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}

    i = 0;
    #ifdef _OPENMP
    int threadID = omp_get_thread_num();
    #else
    int threadID = 0;
    #endif

    for ( i = 0; i < nstrip; i++ ){
        j = i * nchem;

        {%- for species in network.ode_species | sort %}
        {{species.name}} = input[j];
        j++;
        {%- endfor %}

        /*
        {%- for species in network.equilibrium_species | sort %}
        {{network.solve_equilibrium_abundance(species.name)}}
        {%- endfor %}
        */

        // TODO: pull the rates from {{solver_name}}_data
        // these species usually contribute negligbly to the number density (?)
        // it is a little tricky here,
        // since these species depends on the temperature
        // and the abundance of the rest of the species
        // BUT, without their abundance, temperature CANNOT be evaluated....
        // FOR NOW, a not entirely correct physically,
        // BUT a not-too-bad surrogate is:
        // assume these species has negligible abundance....
	    {%- if network.equilibrium_species | length > 0 %}
        {%- for species in network.equilibrium_species | sort %}
	    {{species.name}} = 0.0;
        {%- endfor %}
	    {%- endif %}

        density = {{network.print_mass_density()}};

        // Requires iteration on the convergence of temperature
        // since the gammaH2 is not fixed
        {%- if 'H2_1' in network.species_list() %}
        // Initiate the "guess" temperature
        T    = data->Ts[threadID][i];
        Tnew = T*1.1;
        Tdiff = Tnew - T;
        count = 0;

        while ( Tdiff/ Tnew > 1.0e-8){
            // We do Newton's Iteration to calculate the temperature
            // Since gammaH2 is dependent on the temperature too!

            T = data->Ts[threadID][i];

            {{ solver_name }}_interpolate_gamma(data, i);
            {% for sp in network.interpolate_gamma_species | sort %}
            gamma{{sp.name}} = data->gamma{{sp.name}}[threadID][i];
            dgamma{{sp.name}}_dT = 0.0; //data->dgamma{{sp.name}}_dT[threadID][i]; // iterations do not converge in some cases...
            _gamma{{sp.name}}_m1 = 1.0 / (gamma{{sp.name}} - 1.0);
            // fprintf(stderr, ":gamma{{sp}} %0.5g , dgamma{{sp}}_dT: %.5g \n", gamma{{sp}}, dgamma{{sp}}_dT  );
            {% endfor %}


            // update gammaH2
            // The derivatives of  sum (nkT/(gamma - 1)/mh/density) - ge
            // This is the function we want to minimize
            // which should only be dependent on the first part
            dge_dT = {{network.temperature_calculation(derivative_dge_dT=True)}};

            //This is the change in ge for each iteration
            dge = {{network.temperature_calculation(get_dge=True)}};

            Tnew = T - dge/dge_dT;
            data->Ts[threadID][i] = Tnew;

            Tdiff = fabs(T - Tnew);
            // fprintf(stderr, "T: %0.5g ; Tnew: %0.5g; dge_dT: %.5g, dge: %.5g, ge: %.5g \n", T,Tnew, dge_dT, dge, ge);
            count += 1;
            if (count > MAX_T_ITERATION){
                fprintf(stderr, "T failed to converge \n");
                return 1;
            }
        } // while loop

        data->Ts[threadID][i] = Tnew;


        //fprintf(stderr,"T : %0.5g, density : %0.5g, d_gammaH2: %0.5g \n", Tnew, density, gammaH2 - 7./5.);


        {% else %} {# if 'H2_1' in network.species_list() #}
        data->Ts[threadID][i] = {{network.temperature_calculation()}};
        {% endif %}

        if (data->Ts[threadID][i] < data->bounds[0]) {
            data->Ts[threadID][i] = data->bounds[0];
        } else if (data->Ts[threadID][i] > data->bounds[1]) {
            data->Ts[threadID][i] = data->bounds[1];
        }
        data->logTs[threadID][i] = log(data->Ts[threadID][i]);
        data->invTs[threadID][i] = 1.0 / data->Ts[threadID][i];

        dge_dT = {{network.temperature_calculation(derivative_dge_dT=True)}};
        data->dTs_{{ network.energy_term.name }}[threadID][i] = 1.0 / dge_dT;
    } // for i in nstrip loop
    return 0;

}
{% endblock %} {# calculate_temperature #}

{#
{% block temperature_from_mass_density %}
void temperature_from_mass_density(double *input, int nstrip,
                                   int nchem, double *strip_temperature)
{
    int i, j;
    double density;
    double kb = 1.3806504e-16; // Boltzmann constant [erg/K]
    double mh = 1.66054e-24;
    double gamma = 5.e0/3.e0;
    double _gamma_m1 = 1.0 / (gamma - 1.0);
    {% if 'H2_1' in network.species_list() %}
    double gammaH2 = 7.e0/5.e0; // Should be a function of temperature
                        // this is a temporary solution

    double T =  1000.0; // THIS IS TEMPORARY!!! DELTETE!!

    {% endif %}
    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}

    double scale;

    for (i = 0; i<nstrip; i++) {
        j = i * nchem;
    {%- for species in network.required_species | sort %}
        {{species.name}} = input[j];
        {%if species.name != "ge" %}
        {{species.name}} /= {{species.weight}} * mh;
        {%endif%}
        /*fprintf(stderr, "{{species.name}}[%d] = % 0.16g\n",
                i, {{species.name}});*/
        j++;
    {% endfor %}
        density = {{network.print_mass_density()}};
        strip_temperature[i] = {{ network.temperature_calculation() }};
        if (strip_temperature[i] < 1.0)
            strip_temperature[i] = 1.0;
    }

}
{% endblock temperature_from_mass_density %}
#}

///////////////////////////////////////////////////////////////////////////////
////////// Ensure Conservation of mass, charge, species ///////////////////////
///////////////////////////////////////////////////////////////////////////////

{% block ensure_electron_consistency %}
void ensure_electron_consistency(double *input, double *equil_array, unsigned long nstrip, int nchem)
{
    // inputs are assumed to be in number density
    unsigned long i, j;

    /* Now we set up some temporaries */
    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}
    {%- for species in network.equilibrium_species | sort %}
    double *{{species.name}}_arr = &equil_array[{{loop.index0}}*nstrip];
    {%- endfor %}

    double total_e = 0.0;
    int e_indx;

    for (i = 0; i<nstrip; i++) {
	    total_e = 0.0;
    	{%- for species in network.equilibrium_species | sort %}
	    {{species.name}} = {{species.name}}_arr[i];
    	{%- endfor %}
        j = i * nchem;
        {%- for species in network.ode_species | sort %}
        {{species.name}} = input[j];
        {%if species.name != "ge" and species.name != "de"
             and species.name != "us_e_0" %}
        total_e += {{species.name}} * {{species.free_electrons}};
        {%-endif%}
        {%-if species.name == "de" or species.name == "us_e_0" -%}
        e_indx = j;
        {%-endif%}
        j++;
        {%- endfor %}

        {%- for species in network.required_species | sort %}
        {%-if species.name == "de" or species.name == "us_e_0" -%}
        input[e_indx] = total_e;
        {%-endif%}
        {% endfor %}
    }
}

{% endblock %}

{% if network.enforce_conservation -%}
{% block ensure_species_consistency %}
void ensure_species_conservation(double *input, double *mdensity, double *equil_array, {{solver_name}}_data *data, int nstrip, unsigned long d, unsigned long dims, int nchem)
{
    // input are in ``number`` density!
    // not mass density
    int i, j;
    /* Now we set up some temporaries */
    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}
    {%- for s in network.get_conserved_dict()%}
    double total_{{s}};
    {%- endfor %}

    #ifdef _OPENMP
    int threadID = omp_get_thread_num();
    #else
    int threadID = 0;
    #endif

    //TODO: these should be generalized in dengo
    // and not set manually here...
    double fH = 0.76;
    double fHe = 1- fH;
    double density;

    {%- for species in network.equilibrium_species | sort %}
    double *{{species.name}}_arr = &equil_array[{{loop.index0}}*dims + d*nstrip];
    {%- endfor %}

    // to mainly calculate the equilibrium species
    {%- for name, rate in network.reactions | dictsort %}
    double *{{name}} = data->rs_{{name}}[threadID];
    {%- endfor %}

    for (i = 0; i<nstrip; i++) {
        j = i * nchem;
        {%- for species in network.ode_species | sort %}
        {{species.name}} = input[j];
        j++;
        {%- endfor-%}

	    {%- for species in network.equilibrium_species | sort %}
        {{network.solve_equilibrium_abundance(species.name) }}
        {{species.name}} = {{species.name}}_arr[i];
        {%- endfor %}

        // calculate totalH and totalHe
        {%- for s in ["H", "He"] %}
        {{network.print_conserved_species(s, "total_{}".format(s))}}
        {%-endfor%}

        density = mdensity[i]/1.67e-24;
        j = i*nchem;
        {%- for species in network.ode_species | sort -%}
        // {{species.name}}
        {{network.print_apply_conservation(species.name, "input[j]")}}
        j++;
        {%- endfor -%}

	{%- for species in equilibrium_species | sort %}
	{{network.print_apply_conservation(species.name, "{}_arr[i]".format(species.name))}}
	{%- endfor %}
    }
    fprintf(stderr, "diff = %0.5g\n", fH*density/total_H);

}
{% endblock %}
{%- endif-%}


///////////////////////////////////////////////////////////////////////////////
//////////////////// Auxillary Functions that estimate state variables ////////
///////////////////////////////////////////////////////////////////////////////
// Again these are exposed to the user
// and can be called basically with units, field_data objects
///////////////////////////////////////////////////////////////////////////////
{% block calculate_pressure_enzo %}
int dengo_calculate_pressure_enzo( code_units* units, dengo_field_data *field_data){

    unsigned long int i, j, k, d, dims;
    int nchem = {{network.ode_species | length }};

    // calculate total number of cells
    int is, ie, js, je, ks, ke;
    // avoid ghost zones
    is = field_data->grid_start[0];
    ie = field_data->grid_end[0];

    js = field_data->grid_start[1];
    je = field_data->grid_end[1];

    ks = field_data->grid_start[2];
    ke = field_data->grid_end[2];

    // number of cells that actually required calculations
    dims = ie - is + 1;
    dims*= je - js + 1;
    dims*= ke - ks + 1;

    const char * FileLocation = field_data->dengo_data_file;
    {{solver_name}}_data *data = {{solver_name}}_setup_data( FileLocation, NULL, NULL);

    // fills the `input` array with field data
    // note that input are still some kind of mass density, rho/ m_amu
    double *input = (double *) malloc(dims*nchem*sizeof(double));
    flatten_dengo_field_data_enzo(units, field_data, input);

    // now we should call internal dengo function to calculate gamma
    // once, gamma is updated, we can use P = (gamma -1)* rho * u
    double *gamma_eff = (double *) malloc(dims*sizeof(double));
    double *pressure;
    double *density;
    double *thermal_energy;
    double *input_batch;
    double *gamma_eff_batch;

    int nstrip           = data->nstrip;
    unsigned long ntimes = dims / nstrip;
    int nstrip_res       = dims % nstrip;
    int threadID;

    #pragma omp parallel for private (i, j ,d, input_batch, gamma_eff_batch, pressure, thermal_energy, density, threadID) num_threads(NTHREADS) schedule(static, 1)
    for ( d = 0; d < ntimes; d++ ){
        #ifdef _OPENMP
        threadID = omp_get_thread_num();
        #else
        threadID = 0;
        #endif

        input_batch        = &input[d*nstrip*nchem];
        gamma_eff_batch    = &gamma_eff[d*nstrip];
        pressure           = &field_data->Pressure[d*nstrip];
        thermal_energy     = &field_data->ge_density[d*nstrip];
        density            = &field_data->density[d*nstrip];

        setting_up_extra_variables( data, input_batch, nstrip );
        {{solver_name}}_calculate_temperature(data,  input_batch , nstrip, nchem );
        dengo_calculate_gamma( gamma_eff_batch, data, input_batch, nstrip);
        for ( i = 0; i < nstrip; i++ ){
            pressure[i] = (gamma_eff_batch[i] - 1.0)* density[i]* thermal_energy[i];
        }
    }

    if (nstrip_res > 0){
        #ifdef _OPENMP
        threadID = omp_get_thread_num();
        #else
        threadID = 0;
        #endif
        input_batch        = &input[ntimes*nstrip*nchem];
        gamma_eff_batch    = &gamma_eff[ntimes*nstrip];
        pressure           = &field_data->Pressure[ntimes*nstrip];
        thermal_energy     = &field_data->ge_density[ntimes*nstrip];
        density            = &field_data->density[ntimes*nstrip];

        setting_up_extra_variables( data, input_batch, nstrip_res );
        {{solver_name}}_calculate_temperature(data,  input_batch , nstrip_res , nchem );
        dengo_calculate_gamma( gamma_eff_batch, data, input_batch, nstrip_res);
        for ( i = 0; i < nstrip_res; i++ ){
            pressure[i] = (gamma_eff_batch[i] - 1.0)* density[i]* thermal_energy[i];
        }
    }

    double pressure_unit = pow(units->length_units, 4)* units->density_units / pow(units->time_units,2);
    for (unsigned long i = 0; i < dims; i++ ){
        field_data->Pressure[i] /= pressure_unit;
    }

    free(input);
    free(gamma_eff);
    return 1;

}
{% endblock calculate_pressure_enzo %}

{% block calculate_gamma_enzo %}
int dengo_calculate_gamma_enzo(code_units* units, dengo_field_data *field_data){
    unsigned long i, j, k, d, dims;
    int nchem = {{network.ode_species | length }};

    // calculate total number of cells
    int is, ie, js, je, ks, ke;
    // avoid ghost zones
    is = field_data->grid_start[0];
    ie = field_data->grid_end[0];

    js = field_data->grid_start[1];
    je = field_data->grid_end[1];

    ks = field_data->grid_start[2];
    ke = field_data->grid_end[2];

    // number of cells that actually required calculations
    dims = ie - is + 1;
    dims*= je - js + 1;
    dims*= ke - ks + 1;

    const char * FileLocation = field_data->dengo_data_file;
    {{solver_name}}_data *data = {{solver_name}}_setup_data( FileLocation, NULL, NULL);

    // fills the `input` array with field data
    // note that input are still some kind of mass density, rho/ m_amu
    double *input = (double *) malloc(dims*nchem*sizeof(double));
    flatten_dengo_field_data_enzo(units, field_data, input);

    // now we should call internal dengo function to calculate gamma
    // once, gamma is updated, we can use P = (gamma -1)* rho * u
    double *input_batch;
    double *gamma_eff_batch;

    int nstrip     = data->nstrip;
    unsigned long ntimes = dims / nstrip;
    int nstrip_res = dims % nstrip;
    int threadID;

    #pragma omp parallel for private (i, j ,d, input_batch, gamma_eff_batch, threadID) num_threads(NTHREADS) schedule(static, 1)
    for ( d = 0; d < ntimes; d++ ){
        #ifdef _OPENMP
        threadID = omp_get_thread_num();
        #else
        threadID = 0;
        #endif
        input_batch        = &input[d*nstrip*nchem];
        gamma_eff_batch    = &field_data->Gamma[d*nstrip];

        setting_up_extra_variables( data, input_batch, nstrip );
        {{solver_name}}_calculate_temperature(data,  input_batch , nstrip, nchem );
        dengo_calculate_gamma( gamma_eff_batch, data, input_batch, nstrip);
    }

    if (nstrip_res > 0){
        #ifdef _OPENMP
        threadID = omp_get_thread_num();
        #else
        threadID = 0;
        #endif
        input_batch        = &input[ntimes*nstrip*nchem];
        gamma_eff_batch    = &field_data->Gamma[ntimes*nstrip];

        setting_up_extra_variables( data, input_batch, nstrip_res );
        {{solver_name}}_calculate_temperature(data,  input_batch , nstrip_res , nchem );
        dengo_calculate_gamma( gamma_eff_batch, data, input_batch, nstrip_res);
    }

    free(input);
    return 1;

}
{% endblock calculate_gamma_enzo %}

{% block calculate_temperature_enzo %}
int dengo_calculate_temperature_enzo(code_units* units, dengo_field_data *field_data){
    unsigned long int i, j, k, d, dims;
    int nchem = {{network.ode_species | length }};

    // calculate total number of cells
    int is, ie, js, je, ks, ke;
    // avoid ghost zones
    is = field_data->grid_start[0];
    ie = field_data->grid_end[0];

    js = field_data->grid_start[1];
    je = field_data->grid_end[1];

    ks = field_data->grid_start[2];
    ke = field_data->grid_end[2];

    // number of cells that actually required calculations
    dims = ie - is + 1;
    dims*= je - js + 1;
    dims*= ke - ks + 1;

    const char * FileLocation = field_data->dengo_data_file;
    {{solver_name}}_data *data = {{solver_name}}_setup_data( FileLocation, NULL, NULL);

    // fills the `input` array with field data
    // note that input are still some kind of mass density, rho/ m_amu
    double *input = (double *) malloc(dims*nchem*sizeof(double));
    flatten_dengo_field_data_enzo(units, field_data, input);

    // since we dont know if memory are allocated to the gamma pointer
    // lets just keep it local here
    double *gamma_eff = (double*) malloc(sizeof(double)*dims);

    double *input_batch;
    double *cooling_time_batch;
    double *gamma_eff_batch;
    int nstrip      = data->nstrip;
    unsigned long ntimes      = dims / nstrip;
    int nstrip_res            = dims % nstrip;

    int threadID;
    /* Now we set up some temporaries */

    #pragma omp parallel for private (i, j ,d, input_batch, gamma_eff_batch, threadID) num_threads(NTHREADS) schedule(static, 1)
    for ( d = 0; d < ntimes; d++ ){
        #ifdef _OPENMP
        threadID = omp_get_thread_num();
        #else
        threadID = 0;
        #endif
        input_batch        = &input[d* nchem];
        gamma_eff_batch    = &gamma_eff[d*nstrip];

        setting_up_extra_variables( data, input_batch, nstrip );
        {{solver_name}}_calculate_temperature(data,  input_batch , nstrip, nchem );
        //dengo_calculate_gamma( gamma_eff_batch, data, input_batch, nstrip);
        for ( i = 0; i < nstrip; i++ ){
            field_data->temperature[d*nstrip + i] = data->Ts[threadID][i];
        }
    }

    if (nstrip_res > 0){
        #ifdef _OPENMP
        threadID = omp_get_thread_num();
        #else
        threadID = 0;
        #endif
        input_batch        = &input[ntimes * nchem];
        gamma_eff_batch    = &gamma_eff[ntimes*nstrip];

        setting_up_extra_variables( data, input_batch, nstrip_res );
        {{solver_name}}_calculate_temperature(data,  input_batch , nstrip_res , nchem );
        //dengo_calculate_gamma( gamma_eff_batch, data, input_batch, nstrip_res);

        for ( i = 0; i < nstrip_res; i++ ){
            field_data->temperature[ntimes*nstrip + i] = data->Ts[threadID][i];
        }
    }

    free(input);
    free(data);
    free(gamma_eff);

    return 1;

}
{% endblock %}



{% block estimate_cooling_time_enzo %}
int dengo_estimate_cooling_time_enzo( code_units* units, dengo_field_data *field_data ){


    unsigned long int i, j, k, d, dims;
    int nchem = {{network.ode_species | length }};

    // calculate total number of cells
    int is, ie, js, je, ks, ke;
    // avoid ghost zones
    is = field_data->grid_start[0];
    ie = field_data->grid_end[0];

    js = field_data->grid_start[1];
    je = field_data->grid_end[1];

    ks = field_data->grid_start[2];
    ke = field_data->grid_end[2];

    // number of cells that actually required calculations
    dims = ie - is + 1;
    dims*= je - js + 1;
    dims*= ke - ks + 1;

    const char * FileLocation = field_data->dengo_data_file;
    {{solver_name}}_data *data = {{solver_name}}_setup_data( FileLocation, NULL, NULL);

    // fills the `input` array with field data
    // note that input are still some kind of mass density, rho/ m_amu
    double *input = (double *) malloc(dims*nchem*sizeof(double));
    flatten_dengo_field_data_enzo(units, field_data, input);

    int nstrip      = data->nstrip;
    unsigned long ntimes      = dims / nstrip;
    int nstrip_res            = dims % nstrip;

    double *input_batch;
    double *cooling_time_batch;

    // update the redshift
    double a = units->a_value * units->a_units;
    double z = 1./a - 1.;
    data->current_z = z;

    #pragma omp parallel for private (i, j ,d, input_batch, cooling_time_batch) num_threads(NTHREADS) schedule(static, 1)
    for ( d = 0; d < ntimes; d++ ){
        input_batch        = &input[d* nstrip* nchem];
        cooling_time_batch = &field_data->CoolingTime[d * nstrip];
        {{solver_name}}_calculate_cooling_timescale( cooling_time_batch, input_batch, nstrip, data);
    }

    if (nstrip_res > 0){
        input_batch        = &input[ntimes* nstrip * nchem];
        cooling_time_batch = &field_data->CoolingTime[ntimes*nstrip];
        {{solver_name}}_calculate_cooling_timescale( cooling_time_batch, input_batch, nstrip_res, data );
    }

    for (i = 0; i < dims; i++ ){
        field_data->CoolingTime[i] /= units->time_units;
    }

    free(input);
    free(data);

    // in the world of Enzo
    //FAIL = 0
    return 1;
}
{% endblock estimate_cooling_time_enzo %}

{% block estimate_cooling_time %}
int dengo_estimate_cooling_time( code_units* units, dengo_field_data *field_data ){

    unsigned long int i, j, d, dims;
    int nchem     = {{network.ode_species | length }};
    dims = field_data->ncells;

    const char * FileLocation = field_data->dengo_data_file;
    {{solver_name}}_data *data = {{solver_name}}_setup_data( FileLocation, NULL, NULL);

    int nstrip      = data->nstrip;

    unsigned long ntimes      = dims / nstrip;
    int nstrip_res            = dims % nstrip;

    // flatten field_data entry to a 1d input array
    double *input = (double *) malloc( sizeof(double) * nchem * dims );
    flatten_dengo_field_data( units, field_data, input );

    double *input_batch;
    double *cooling_time_batch;

    #pragma omp parallel for private (i, j ,d, input_batch, cooling_time_batch) num_threads(NTHREADS) schedule(static, 1)
    for ( d = 0; d < ntimes; d++ ){
        input_batch        = &input[d* nstrip *nchem];
        cooling_time_batch = &field_data->CoolingTime[d * nstrip];
        {{solver_name}}_calculate_cooling_timescale( cooling_time_batch, input_batch, nstrip, data);
    }

    if (nstrip_res > 0){
        input_batch        = &input[ntimes* nstrip* nchem];
        cooling_time_batch = &field_data->CoolingTime[ntimes*nstrip];
        {{solver_name}}_calculate_cooling_timescale( cooling_time_batch, input_batch, nstrip_res, data );
    }

    for (i = 0; i < dims; i++ ){
        field_data->CoolingTime[i] /= units->time_units;
    }

    free(input);
    free(data);
}
{% endblock estimate_cooling_time %}


{% block calculate_cooling_timescale %}
int {{solver_name}}_calculate_cooling_timescale( double *cooling_time, double *input, int nstrip, {{solver_name}}_data *data){

    #ifdef _OPENMP
    int threadID = omp_get_thread_num();
    #else
    int threadID = 0;
    #endif

    unsigned long i, j, dims;
    int flag;
    int nchem = {{network.ode_species | length}};
    /* Now we set up some temporaries */
    // make sure the input are in number density
    //{%- if not network.input_is_number %}
    //for (i = 0; i < nstrip; i++) {
    //    j = i * nchem;
    //    {%- for species in network.ode_species | sort %}
    //    {%- if species.name != "ge" %}
    //    input[j] /= {{species.weight}}; // {{species.name}}
    //    {%- endif%}
    //    j++;
    //    {%- endfor%}
    //}
    //{%- endif %}

    // calculate temperature and cooling rate
    setting_up_extra_variables(data, input, nstrip );
    flag = {{solver_name}}_calculate_temperature(data,  input , nstrip, nchem );
    if (flag > 0){
        // check if the temperature failed to converged
        return -1;
    }
    {{solver_name}}_interpolate_rates(data, nstrip);

    {%- for sp in network.required_species %}
    double {{sp.name}};
    {%- endfor %}

    // this might be redundant
    // should only select relavant rates
    {%- for name, rate in network.reactions | dictsort %}
    double *{{name}} = data->rs_{{name}}[threadID];
    {%- endfor %}
    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    double *{{name}}_{{name2}} = data->cs_{{name}}_{{name2}}[threadID];
    {%- endfor %}
    {%- endfor %}

    {% if "gloverabel08" in network.cooling_actions %}
    double h2_optical_depth_approx;
    {% endif %}
    {% if "cie_cooling" in network.cooling_actions %}
    double cie_optical_depth_approx;
    {% endif %}

    double z;
    double T;
    double mdensity, inv_mdensity, dge_dt;

    for ( i = 0; i < nstrip; i++ ){

        T            = data->Ts[threadID][i];
        z            = data->current_z;
        mdensity     = data->mdensity[threadID][i];
        inv_mdensity = data->inv_mdensity[threadID][i];
        {% if "gloverabel08" in network.cooling_actions %}
        h2_optical_depth_approx = data->h2_optical_depth_approx[threadID][i];
        {% endif %}
        {% if "cie_cooling" in network.cooling_actions %}
        cie_optical_depth_approx = data->cie_optical_depth_approx[threadID][i];
        {% endif %}

        j = i * nchem;
        {%- for species in network.ode_species | sort %}
        {{species.name}} = input[j];
        j++;
        {%- endfor %}

        // obtain a quasis-equilibrium estimate
        {%- for species in network.equilibrium_species | sort %}
        {{network.solve_equilibrium_abundance(species.name) }}
        {%- endfor %}

        //
        // Species: ge
        //
        {{network.print_cooling( assign_to="dge_dt" ) }}
        dge_dt *= inv_mdensity;
        cooling_time[i] = fabs( ge / dge_dt);

    //fprintf(stderr, "----------------\n");
    }
}
{% endblock calculate_cooling_timescale %}


{% block dengo_calculate_pressure %}
{% endblock dengo_calculate_pressure %}

{% block dengo_calculate_temperature %}
int dengo_calculate_temperature( code_units *units, dengo_field_data *field_data){

    unsigned long int i, j, d, dims;
    int nchem     = {{network.required_species | length }};
    dims = field_data->ncells;

    const char * FileLocation = field_data->dengo_data_file;
    {{solver_name}}_data *data = {{solver_name}}_setup_data( FileLocation, NULL, NULL);

    int nstrip      = data->nstrip;
    unsigned long ntimes      = dims / nstrip;
    int nstrip_res            = dims % nstrip;

    // flatten field_data entry to a 1d input array
    double *input = (double *) malloc( sizeof(double) * nchem * dims );
    flatten_dengo_field_data( units, field_data, input );

    double *input_batch;
    double *cooling_time_batch;
    double *gamma_eff_batch;

    int threadID;
    /* Now we set up some temporaries */

    #pragma omp parallel for private (i, j ,d, input_batch, gamma_eff_batch, threadID) num_threads(NTHREADS) schedule(static, 1)
    for ( d = 0; d < ntimes; d++ ){
        #ifdef _OPENMP
        threadID = omp_get_thread_num();
        #else
        threadID = 0;
        #endif
        input_batch        = &input[d* nchem];
        gamma_eff_batch    = &field_data->Gamma[d*nstrip];

        setting_up_extra_variables( data, input_batch, nstrip );
        {{solver_name}}_calculate_temperature(data,  input_batch , nstrip, nchem );
        dengo_calculate_gamma( gamma_eff_batch, data, input_batch, nstrip);
        for ( i = 0; i < nstrip; i++ ){
            field_data->temperature[d*nstrip + i] = data->Ts[threadID][i];
        }
    }

    if (nstrip_res > 0){
        input_batch        = &input[ntimes * nchem];
        gamma_eff_batch    = &field_data->Gamma[ntimes*nstrip];

        setting_up_extra_variables( data, input_batch, nstrip_res );
        {{solver_name}}_calculate_temperature(data,  input_batch , nstrip_res , nchem );
        dengo_calculate_gamma( gamma_eff_batch, data, input_batch, nstrip_res);

        for ( i = 0; i < nstrip_res; i++ ){
            field_data->temperature[ntimes*nstrip + i] = data->Ts[threadID][i];
        }
    }

    free(input);
    free(data);
}

{% endblock dengo_calculate_temperature%}


{% block dengo_calculate_gamma %}
int dengo_calculate_gamma( double* gamma_eff, {{solver_name}}_data *data, double *input, int nstrip  ){
    unsigned long int i, j, d, dims;
    int nchem     = {{network.ode_species | length }};

    {%- for sp in network.required_species | sort %}
    double {{sp.name}};
    {%- endfor %}

    double gamma = 5.0/3.0;
    {% for sp in network.interpolate_gamma_species | sort %}
    double gamma{{sp.name}};
    double dgamma{{sp.name}}_dT;
    double _gamma{{sp.name}}_m1;
    {% endfor %}
    double n_gamma_m1, ndensity;

    #ifdef _OPENMP
    int threadID = omp_get_thread_num();
    #else
    int threadID = 0;
    #endif

    // both temperature and gamma are updated before calling this
    for (i = 0; i < nstrip; i++ ){
        ndensity = 0;
        j = i * nchem;
        {%- for sp in network.ode_species | sort %}
        {{sp.name}} = input[j] / {{sp.weight}};
        {%- if sp != network.energy_term %}
        ndensity += {{sp.name}};
        {%- endif %}
        {%- endfor %}

        {%- for sp in network.interpolate_gamma_species | sort %}
        gamma{{sp.name}} = data->gamma{{sp.name}}[threadID][i];
        dgamma{{sp.name}}_dT = data->dgamma{{sp.name}}_dT[threadID][i];
        _gamma{{sp.name}}_m1 = 1.0 / (gamma{{sp.name}} - 1.0);
        {%- endfor %}

        n_gamma_m1 = {{network.gamma_factor()}};
        gamma_eff[i] = ndensity / n_gamma_m1 + 1.0;
    }

}
{% endblock dengo_calculate_gamma %}

{% block dengo_calculate_mean_molecular_weight %}
int dengo_calculate_mean_molecular_weight( code_units *units, dengo_field_data *field_data ){
    unsigned long int i, j, d, dims;
    int nchem     = {{network.required_species | length }};
    dims = field_data->ncells;


    // flatten field_data entry to a 1d input array
    double *input = (double *) malloc( sizeof(double) * nchem * dims );
    flatten_dengo_field_data( units, field_data, input );

    {%- for sp in network.required_species %}
    double {{sp.name}};
    {%- endfor %}
    double ndensity, mdensity;

    for (i = 0; i < dims; i++ ){
        ndensity = 0.0;
        mdensity = 0.0;
        j = i * nchem;
        {%- for sp in network.required_species | sort %}
        // Species: {{sp.name}}
        {%- if sp.name not in network.skip_weight %}
        mdensity += input[j];
        {%- endif %}
        {%- if sp != network.energy_term %}
        ndensity += input[j] /{{sp.weight}};
        {%-endif%}
        j++;
        {%- endfor %}
        field_data->MolecularWeight[i] = mdensity / ndensity;
    }

    free(input);
}
{% endblock dengo_calculate_mean_molecular_weight %}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////Solve Chemistry   ///////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// basically all the routines that are exposed to the user
// that can be called from dengo

{% block solve_chemistry%}
int {{solver_name}}_solve_chemistry( code_units *units, dengo_field_data *field_data, double dt ){
    // to use this, reltol and floor_value must be specified through
    // dengo_field_data
    unsigned long int i, j, d, dims;
    int N = {{network.ode_species | length }};
    dims = field_data->ncells; // total number of strips to be evaluated

    const char * FileLocation = field_data->dengo_data_file;
    {{solver_name}}_data *data = {{solver_name}}_setup_data( FileLocation, NULL, NULL);

    double *input = (double *) malloc(dims * N * sizeof(double));
    double *temp  = (double *) malloc(dims * ({{network.equilibrium_species | length}}+1) * sizeof(double) );
    double *atol  = (double *) malloc(dims * N * sizeof(double));
    double *rtol  = (double *) malloc(sizeof(double));

    // code unit in terms of erg/g
    double UNIT_E_per_M = units->velocity_units * units->velocity_units;
    double m_amu = 1.66053904e-24;

    rtol[0]            = field_data->reltol;
    data->reltol       = field_data->reltol;
    double floor_value = field_data->floor_value;

    flatten_dengo_field_data(units, field_data, input);
    /*
    for (int i = 0; i < N; i++){
        fprintf(stderr, "input[%d] = %0.5g\n", i, input[i] );
    }
    */

    int flag;
    double z;
    double dtf;

    // convert code time to seconds
    dt *= units->time_units;
    dtf = dt;

    // update the rate table location
    data->dengo_data_file = field_data->dengo_data_file;

    flag = dengo_evolve_{{solver_name}}(dtf, dt, z, input, rtol, atol, dims, data, temp);

    reshape_to_dengo_field_data(units, field_data, input);

    for ( d = 0; d< dims; d++  ){
        field_data->temperature[d] = temp[d];
    }

    for ( d = 0; d< dims; d++  ){
        {%- for species in network.equilibrium_species | sort %}
        field_data->{{species.name}}_density[d] = temp[dims * (1+{{loop.index0}}) + d];
        field_data->{{species.name}}_density[d] /= units->density_units / m_amu;
        {%- endfor %}
    }

    //dengo_estimate_cooling_time( units, field_data );
    //dengo_calculate_temperature(units, field_data);
    //dengo_calculate_mean_molecular_weight( units, field_data );

    free(input);
    free(temp);
    free(data);
    free(atol);
    free(rtol);

    if (flag > 0) return 1;

    return 0;
}
{% endblock %}


{% block solve_chemistry_enzo%}
int {{solver_name}}_solve_chemistry_enzo( code_units *units, dengo_field_data *field_data, double dt ){
    //-------------------------------------------------------------------------
    // Function: {{solver_name}}_solve_chemistry_enzo
    // Description: takes the same input as {{solver_name}}_solve_chemistry
    //              BUT field_data needs to be specified with things like
    //              grid_start, grid_end, grid_dimension
    //              such that dengo can avoid evaluating ghost zones
    //-------------------------------------------------------------------------

    // to use this, reltol and floor_value must be specified through
    // dengo_field_data
    unsigned long int i, j, k, d, dims;
    int N = {{network.ode_species | length }};

    // calculate total number of cells
    int is, ie, js, je, ks, ke;
    // avoid ghost zones
    is = field_data->grid_start[0];
    ie = field_data->grid_end[0];

    js = field_data->grid_start[1];
    je = field_data->grid_end[1];

    ks = field_data->grid_start[2];
    ke = field_data->grid_end[2];

    // number of cells that actually required calculations
    dims = ie - is + 1;
    dims*= je - js + 1;
    dims*= ke - ks + 1;

    const char * FileLocation = field_data->dengo_data_file;
    {{solver_name}}_data *data = {{solver_name}}_setup_data( FileLocation, NULL, NULL);

    double *input = (double *) malloc(dims * N * sizeof(double));
    double *temp  = (double *) malloc(dims * ({{network.equilibrium_species | length}}+1) * sizeof(double) );
    double *atol  = (double *) malloc(dims * N * sizeof(double));
    double *rtol  = (double *) malloc(sizeof(double));

// fills the `input` array with field data
    // note that input are still some kind of mass density, rho/ m_amu
    flatten_dengo_field_data_enzo(units, field_data, input);

    // specify the relative tolerance and floor value
    rtol[0]            = field_data->reltol;
    data->reltol       = field_data->reltol;
    double floor_value = field_data->floor_value;

    // specifiy the redshift
    int flag;
    double a = units->a_value * units->a_units;
    double z = 1./a - 1.;
    double dtf;

    // convert code time to seconds
    dt *= units->time_units;
    dtf = dt;

    // update the rate table location
    data->dengo_data_file = field_data->dengo_data_file;
    data->floor_value = floor_value;

    // evolve chemistry in dengo
    flag = dengo_evolve_{{solver_name}}(dtf, dt, z, input, rtol, atol, dims, data, temp);

    // fill results in `input` back to field data
    // in appropriate units
    reshape_to_dengo_field_data_enzo(units, field_data, input, temp);

    // free all pointers
    free(input);
    free(temp);
    free(data);
    free(atol);
    free(rtol);

    // in Enzo; 0 == FAIL
    if (flag > 0) return 0;
    // 1 == SUCCESS
    return 1;
}
{% endblock %}

{% block solve_chemistry_dt %}
int {{solver_name}}_solve_chemistry_dt( code_units *units, dengo_field_data *field_data, double* reltol, double* abstol, double dt ){
    // TODO:
    // this is not only called from the python modules
    // but this is dumb...
    // this is almost the same as {{solver_name}}_solve_chemistry!!!
    // should be replaced later....

    unsigned long int i, j, d, dims;
    int N = {{network.required_species | length }};
    dims = field_data->ncells; // total number of strips to be evaluated

    // turned the field data into a long chain of
    // 1-D array
    //
    // N: number of species
    // d: d th number of strip to be evalulated
    // i: index for each species
    //    should be in correct order and handled
    //    by dengo templates
    // i.e.
    // input[d*N + i] = field_data->HI_density[]
    //

    const char * FileLocation = field_data->dengo_data_file;
    {{solver_name}}_data *data = {{solver_name}}_setup_data( FileLocation, NULL, NULL);

    double *input = (double *) malloc(dims * N * sizeof(double));
    double *temp  = (double *) malloc(dims * sizeof(double) );
    double *atol  = (double *) malloc(dims * N * sizeof(double));
    double *rtol  = (double *) malloc(sizeof(double));

    // code unit in terms of erg/g
    double UNIT_E_per_M = units->velocity_units * units->velocity_units;
    double m_amu = 1.66053904e-24;


    #pragma omp parallel for private (i, j ,d) num_threads(NTHREADS) schedule(static,1)
    for ( d = 0; d< dims; d++  ){
        j = d*N;
        // this should be the normalized
        // by the input units later
        // atol = input * rtol;
        // which again should be set by dengo
        // input in *mass density per amu*
        // and energy in the units of (erg / g)
        {%- for species in network.required_species | sort %}
        input[j]  = field_data->{{species.name}}_density[d] ;
        {%- if species != network.energy_term %}
        input[j] *= units->density_units / m_amu;
        {%- endif %}
        {%- if species == network.energy_term %}
        input[j] *= UNIT_E_per_M;
        {%- endif %}
        j++;
        {%- endfor %}
    }

    /*
    for (int i = 0; i < N; i++){
        fprintf(stderr, "input[%d] = %0.5g\n", i, input[i] );
    }
    */

    int flag;
    double z;
    double dtf;

    // convert code time to seconds
    dt *= units->time_units;
    dtf = dt;

    // update the rate table location
    data->dengo_data_file = field_data->dengo_data_file;

    flag = dengo_evolve_{{solver_name}}(dtf, dt, z, input, reltol, abstol, dims, data, temp);

    #pragma omp parallel for private (i, j ,d) num_threads(NTHREADS) schedule(static, 1)
    for ( d = 0; d< dims; d++  ){
        j = d*N;
        // this should be the normalized
        // by the input units later
        // atol = input * rtol;
        // which again should be set by dengo

        {%- for species in network.required_species | sort %}
        field_data->{{species.name}}_density[d] = input[j];
        {%- if species != network.energy_term %}
        field_data->{{species.name}}_density[d] /= units->density_units / m_amu;
        {%- endif %}
        {%- if species == network.energy_term %}
        field_data->{{species.name}}_density[d] /= UNIT_E_per_M;
        {%- endif %}
        j++;
        {%- endfor %}
    field_data->temperature[d] = temp[d];
    }

    dengo_estimate_cooling_time( units, field_data );
    //dengo_calculate_temperature(units, field_data);
    dengo_calculate_mean_molecular_weight( units, field_data );


    free(input);
    free(temp);
    free(data);
    free(atol);
    free(rtol);

    if (flag > 0) return 1;

    return 0;
}
{% endblock %}

{% block calculate_equilibrium_abundance %}
int calculate_equilibrium_abundance( {{solver_name}}_data *data, double *input,
    int nstrip, unsigned long d, unsigned long dims, double *equil_array){

    //-----------------------------------------------------
    // Function     : calculate_equilibrium_abundance
    // Parameter    :
    //                  input   : Array to store the initial value of each species,
    //                            it will be updated with the value at time dt
    //                  data    : {{solver_name}}_data object that relay the reaction/cooling rates, and normalizations
    //                  equil_array: temperature of each cell by the end of the evolution
    //                  d          : batch count
    //                  dims       : total number of cells to be solved
    //-----------------------------------------------------

    // update the rates given the updated temperature from {{solver_name}}_data
    {{solver_name}}_interpolate_rates(data, nstrip);

    #ifdef _OPENMP
    int threadID = omp_get_thread_num();
    #else
    int threadID = 0;
    #endif

    int nchem = {{network.ode_species | length }};
    unsigned long i, j;

    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}

    {%- for name, rate in network.reactions | dictsort %}
    double *{{name}} = data->rs_{{name}}[threadID];
    {%- endfor %}

    {%- for species in network.equilibrium_species | sort %}
    double *{{species.name}}_arr = &equil_array[{{loop.index0}}*dims + d*MAX_NCELLS];
    {%- endfor %}

    for ( i = 0; i < nstrip; i++ ){
        j = i * nchem;
        {%- for species in network.ode_species | sort %}
        {{species.name}} = input[j];
        j++;
        {%- endfor %}
        {%- for species in network.equilibrium_species | sort %}
        {{network.solve_equilibrium_abundance(species.name) }}
        {{species.name}}_arr[i] = {{species.name}};
        {%- endfor %}
    }
    return 0;
}
{% endblock %}



/*
{% block calculate_JacTimesVec_sundials %}
int calculate_JacTimesVec_{{solver_name}}
            (N_Vector v, N_Vector Jv, realtype t,
             N_Vector y, N_Vector fy,
             void *user_data, N_Vector tmp)
{
    // TODO:
    // as of now this is utterly useless,
    // cos it runs even slower than the actual dense linear solver ...
    // BUT! kept in mind that autodiff could easily replace this
    // but some linear call to rhs/ f evauluations O(n) time
    // but not O(n^2) i think...

    // We iterate over all of the rates
    // Calcuate temperature first
    int nstrip = 1;
    int nchem = {{network.required_species | length }};
    {{solver_name}}_data *data = ({{solver_name}}_data*)user_data;


    int i, j;
    j = 0;

    // change N_Vector back to an array
    double y_arr[ {{network.required_species | length }} ];
    {%- for species in network.required_species | sort %}
    y_arr[{{loop.index - 1}}] = Ith(y , {{loop.index }});
    {%- endfor %}
    // Abundances are scaled in the calculate temperature module
    int flag;
    flag = {{solver_name}}_calculate_temperature(data, y_arr, nstrip, nchem);
    if (flag > 0){
        return 1;
    }

    #ifdef _OPENMP
    int threadID = omp_get_thread_num();
    #else
    int threadID = 0;
    #endif

    {{solver_name}}_interpolate_rates(data, nstrip);

    // Now We set up some temporaries
    double *T{{ network.energy_term.name }} = data->dTs_{{network.energy_term.name }}[threadID];

    // Define the reaction rates
    {%- for name, rate in network.reactions | dictsort %}
    double *{{name}} = data->rs_{{name}}[threadID];
    double *r{{name}} = data->drs_{{name}}[threadID];
    {%- endfor %}

    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    double *{{name}}_{{name2}} = data->cs_{{name}}_{{name2}}[threadID];
    double *r{{name}}_{{name2}} = data->dcs_{{name}}_{{name2}}[threadID];
    {%- endfor %}
    {%- endfor %}

    {% if "gloverabel08" in network.cooling_actions %}
    double h2_optical_depth_approx;
    {% endif %}

    double scale;
    // Define the species
    {%- for species in network.required_species | sort %}
    double {{species.name}}, v{{loop.index-1}};
    {%- endfor %}

    {%- for v in network.required_species | sort %}
    scale = data->scale[threadID][{{loop.index - 1}}];
    v{{loop.index-1}} = Ith( v, {{loop.index}} );
    v{{loop.index-1}} *= scale;
    {%- endfor %}

    double z;
    double T;

    double mh = 1.67e-24;
    double mdensity;

    int jj;
    jj = 0;

    j = i*nchem;
    mdensity = 0.0;
    z = data->current_z;
    {%- for species in network.required_species | sort %}
        // Rescale the Species abundance
    scale = data->scale[threadID][j];
    {{species.name}} = Ith( y, {{loop.index }}  )*scale;
    {%if species.name != "ge" and species.name != "de" and species.name != "us_e_0" %}
    mdensity += {{species.name}};
    {% endif %}
    j++;
    {% endfor %}


    mdensity *= mh;

    j = 0;
    {%- for s1 in network.required_species | sort %}
    //
    // Species: {{s1.name}}
    //
    {{ network.print_JacTimesVec_component(s1, assign_to="Ith(Jv, {0} )".format(loop.index) ) }}

    scale = data->scale[threadID][{{loop.index - 1}}];
    Ith(Jv, {{loop.index}}) /= scale;

    {% if s1.name == "ge" %}
    Ith(Jv, {{loop.index}}) /= mdensity;
    {% endif %}
    {%- endfor %}
    return 0;
}
{% endblock %}
*/


///////////////////////////////////////////////////////////////////////////////
////////////////// RHS functions and Jacobian Functions ///////////////////////
///////////////////////////////////////////////////////////////////////////////
{% block calcuate_rhs_sundials%}
int calculate_rhs_{{solver_name}}(realtype t, N_Vector y, N_Vector ydot, void *user_data)
{
    {{solver_name}}_data *data = ({{solver_name}}_data* ) user_data;
    int i, j;

    int nchem = {{network.ode_species | length }};
    int nstrip = data->nstrip;

    /* change N_Vector back to an array */
    double y_arr[ nchem * nstrip ];
    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}

    #ifdef _OPENMP
    int threadID = omp_get_thread_num();
    #else
    int threadID = 0;
    #endif

    double *yvec_ptr = N_VGetArrayPointer(y);
    double *ydot_ptr = N_VGetArrayPointer(ydot);

    #ifdef SCALE_INPUT
    double *scale     = data->scale[threadID];
    double *inv_scale = data->inv_scale[threadID];
    for ( i = 0; i < nstrip*nchem; i++ ){
        y_arr[i] = yvec_ptr[i]*scale[i];
    }
    #else
    for ( i = 0; i < nstrip*nchem; i++ ){
        y_arr[i] = yvec_ptr[i];
    }
    #endif

    int flag;
    flag = {{solver_name}}_calculate_temperature(data, y_arr , nstrip, nchem );
    if (flag > 0){
        // check if the temperature failed to converged
        return -1;
    }
    {{solver_name}}_interpolate_rates(data, nstrip);

    /* Now we set up some temporaries */

    {%- for name, rate in network.reactions | dictsort %}
    double *{{name}} = data->rs_{{name}}[threadID];
    {%- endfor %}

    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    double *{{name}}_{{name2}} = data->cs_{{name}}_{{name2}}[threadID];
    {%- endfor %}
    {%- endfor %}

    {%- if "gloverabel08" in network.cooling_actions %}
    double h2_optical_depth_approx;
    {% endif %}
    {%- if "cie_cooling" in network.cooling_actions %}
    double cie_optical_depth_approx;
    {% endif %}

    double z;
    double T;

    double mh = 1.66054e-24;
    double mdensity, inv_mdensity;


    for ( i = 0; i < nstrip; i++ ){

        T            = data->Ts[threadID][i];
        z            = data->current_z;
        mdensity     = data->mdensity[threadID][i];
        inv_mdensity = data->inv_mdensity[threadID][i];
        {%- if "gloverabel08" in network.cooling_actions %}
        h2_optical_depth_approx = data->h2_optical_depth_approx[threadID][i];
        {% endif %}
        {%- if "cie_cooling" in network.cooling_actions %}
        cie_optical_depth_approx = data->cie_optical_depth_approx[threadID][i];
        {% endif %}

        j = i * nchem;
        {%- for species in network.ode_species | sort %}
        {{species.name}} = y_arr[j];
        j++;
        {%- endfor %}

        {%- for species in network.equilibrium_species %}
        {{network.solve_equilibrium_abundance(species.name)}}
        {%- endfor %}

        j = i * nchem;
        {%- for species in network.ode_species | sort %}
        // Species: {{species.name}}
        {{network.print_ccode(species, assign_to="ydot_ptr[j]" ) }}
        #ifdef SCALE_INPUT
        ydot_ptr[j] *= inv_scale[j];
        #endif
        {% if species.name == "ge" %}
        ydot_ptr[j] *= inv_mdensity;
        {% endif %}
        //fprintf(stderr, "{{species.name}}: %0.5g\n", scale[j]);
        //fprintf(stderr, "ydot = %0.5g \n", ydot_ptr[j]*scale[j] );
        j++;
        {% endfor %}

    //fprintf(stderr, "----------------\n");
    }
    return 0;
    }
{% endblock %}

{% block calculate_jacobian_sundials %}
int calculate_jacobian_{{solver_name}}( realtype t,
                                        N_Vector y, N_Vector fy,
                                        SUNMatrix J, void *user_data,
                                        N_Vector tmp1, N_Vector tmp2,
                                        N_Vector tmp3)
{
    /* We iterate over all of the rates */
    /* Calcuate temperature first */


    {{solver_name}}_data *data = ({{solver_name}}_data*)user_data;

    #ifdef _OPENMP
    int threadID = omp_get_thread_num();
    #else
    int threadID = 0;
    #endif

    int nchem = {{network.ode_species | length }};
    int nstrip = data->nstrip;
    int i, j;

    /* change N_Vector back to an array */
    double *yvec_ptr = N_VGetArrayPointer(y);
    double y_arr[ {{network.required_species | length }} * nstrip ];

    #ifdef SCALE_INPUT
    double *scale     = data->scale[threadID];
    double *inv_scale = data->inv_scale[threadID];
    double scale1, inv_scale2;
    for ( i = 0; i < nstrip*nchem; i++ ){
        y_arr[i] = yvec_ptr[i]*scale[i];
    }
    #else
    for ( i = 0; i < nstrip*nchem; i++ ){
        y_arr[i] = yvec_ptr[i];
    }
    #endif


    /*
    int flag;
    flag = {{solver_name}}_calculate_temperature(data, y_arr, nstrip, nchem );
    if (flag > 0){
        // check if the temperature failed to converged
        return -1;
    }
    {{solver_name}}_interpolate_rates(data, nstrip);
    */

    // {{solver_name}}_calculate_temperature(data, y_arr, nstrip, nchem);
    // {{solver_name}}_interpolate_rates(data, nstrip);

    /* Now We set up some temporaries */
    double *T{{ network.energy_term.name }} = data->dTs_{{network.energy_term.name }}[threadID];

    {%- for name, rate in network.reactions | dictsort %}
    double *{{name}} = data->rs_{{name}}[threadID];
    double *r{{name}}= data->drs_{{name}}[threadID];
    {%- endfor %}

    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    double *{{name}}_{{name2}} = data->cs_{{name}}_{{name2}}[threadID];
    double *r{{name}}_{{name2}} = data->dcs_{{name}}_{{name2}}[threadID];
    {%- endfor %}
    {%- endfor %}

    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}
    double z;
    double T;

    double mh = 1.66054e-24;
    double mdensity, inv_mdensity;
    {% if "gloverabel08" in network.cooling_actions %}
    double h2_optical_depth_approx;
    {% endif %}
    {% if "cie_cooling" in network.cooling_actions %}
    double cie_optical_depth_approx;
    {% endif %}


    j = 0;
    mdensity = 0.0;
    z = data->current_z;

    for ( i = 0; i < nstrip; i++ ){
        j = i * nchem;
        {%- for species in network.ode_species | sort %}
        {{species.name}} = y_arr[j];
        j++;
        {%- endfor %}

	    {%- for species in network.equilibrium_species | sort %}
	    {{network.solve_equilibrium_abundance(species.name)}}
	    {% endfor %}

        mdensity = data->mdensity[threadID][i];
        inv_mdensity = 1.0 / mdensity;
        {% if "gloverabel08" in network.cooling_actions %}
        h2_optical_depth_approx  = data->h2_optical_depth_approx[threadID][i];
        {% endif %}
        {% if "cie_cooling" in network.cooling_actions %}
        cie_optical_depth_approx = data->cie_optical_depth_approx[threadID][i];
        {% endif %}

        j = i * nchem;
        {%- for s2 in network.ode_species | sort %}
        //
        // Species: {{s2.name}}
        //
        {% set i_s2 = loop %}
        {%- for s1 in network.ode_species | sort %}
        {% set i_s1 = loop%}
        // {{s2.name}} by {{s1.name}}
        {% if  network.print_jacobian_component(s2, s1, print_zeros = False) != None %}
        {{ network.print_jacobian_component(s2, s1, assign_to="SM_ELEMENT_D( J, j + {0}, j + {1} )".format( i_s2.index0, i_s1.index0 ) , print_zeros = False ) }}
        {% else %}
        // because the Jacobian is initialized to zeros by default
        // {{ network.print_jacobian_component(s2, s1, assign_to="SM_ELEMENT_D( J, j + {0}, j + {1} )".format( i_s2.index0, i_s1.index0 )  ) }}
        {% endif %}


        #ifdef SCALE_INPUT
        inv_scale2 = inv_scale[ j + {{i_s2.index0}}];
        scale1     = scale    [ j + {{i_s1.index0}}];
        SM_ELEMENT_D( J, j + {{i_s2.index0}}, j + {{i_s1.index0}}) *= inv_scale2*scale1;
        #endif

        {%- if s2.name == 'ge' %}
        SM_ELEMENT_D( J, j + {{i_s2.index0}}, j + {{i_s1.index0}} ) *= inv_mdensity;
        {%- endif %}

        {%- if s1.name == 'ge' %}
        SM_ELEMENT_D( J, j + {{i_s2.index0}}, j + {{i_s1.index0}} ) *= T{{ network.energy_term.name }}[i];
        {%- endif %}

        {%- endfor %}
        {%- endfor %}
    }
    return 0;
}
{% endblock %}

{% block calculate_sparse_jacobian %}
#ifdef CVKLU
int calculate_sparse_jacobian_{{solver_name}}( realtype t,
                                        N_Vector y, N_Vector fy,
                                        SUNMatrix J, void *user_data,
                                        N_Vector tmp1, N_Vector tmp2,
                                        N_Vector tmp3)
{
    /* We iterate over all of the rates */
    /* Calcuate temperature first */


    {{solver_name}}_data *data = ({{solver_name}}_data*)user_data;

    int nchem = {{network.ode_species | length }};
    int nstrip = data->nstrip;
    int i, j;
    int NSPARSE = {{network.get_sparse_matrix_component( return_type = "nsparse" )}};

    #ifdef _OPENMP
    int threadID = omp_get_thread_num();
    #else
    int threadID = 0;
    #endif

    /* change N_Vector back to an array */
    double y_arr[ {{network.ode_species | length }} * nstrip ];
    double *scale     = data->scale[threadID];
    double *inv_scale = data->inv_scale[threadID];
    {%- if "gloverabel08" in network.cooling_actions %}
    double h2_optical_depth_approx;
    {%- endif %}
    {%- if "cie_cooling" in network.cooling_actions %}
    double cie_optical_depth_approx;
    {%- endif %}

    //TODO: Here we assumed during the evaluation of jacobian
    // temperature is approximately constant,
    // i.e. close enough to the point evaluation of f(y)
    // such that the rates and temperature need not be interpolated or evalulated
    // again during the jacobian evaluation.
    // We havent really fully explored the effect of this `assumption`...
    // But it definitely boost the performance

    /*
    int flag;
    flag = {{solver_name}}_calculate_temperature(data, y_arr , nstrip, nchem );
    if (flag > 0){
        // check if the temperature failed to converged
        return -1;
    }
    {{solver_name}}_interpolate_rates(data, nstrip);
    */

    // {{solver_name}}_calculate_temperature(data, y_arr, nstrip, nchem);
    // {{solver_name}}_interpolate_rates(data, nstrip);

    /* Now We set up some temporaries */
    // CSR is what we choose
    sunindextype *rowptrs = SUNSparseMatrix_IndexPointers(J);
    sunindextype *colvals = SUNSparseMatrix_IndexValues(J);
    realtype *matrix_data = SUNSparseMatrix_Data(J);

    SUNMatZero(J);

    double *T{{ network.energy_term.name }} = data->dTs_{{network.energy_term.name }}[threadID];

    {%- for name, rate in network.reactions | dictsort %}
    double *{{name}} = data->rs_{{name}}[threadID];
    double *r{{name}}= data->drs_{{name}}[threadID];
    {%- endfor %}

    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    double *{{name}}_{{name2}} = data->cs_{{name}}_{{name2}}[threadID];
    double *r{{name}}_{{name2}} = data->dcs_{{name}}_{{name2}}[threadID];
    {%- endfor %}
    {%- endfor %}

    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}
    double z;
    double T;

    double mh = 1.66054e-24;
    double mdensity, inv_mdensity;

    double scale2, inv_scale1;

    j = 0;
    mdensity = 0.0;
    z = data->current_z;

    int k = 0;

    double *yvec_ptr = N_VGetArrayPointer(y);

    for ( i = 0; i < nstrip; i++ ){

        #ifdef SCALE_INPUT
        j = i * nchem;
        {%- for species in network.ode_species | sort %}
        {{species.name}} = yvec_ptr[j]*scale[j];
        j++;
        {% endfor %}
        #else
        j = i * nchem;
        {%- for species in network.ode_species | sort %}
        {{species.name}} = yvec_ptr[j];
        j++;
        {% endfor %}
        #endif

	{%- for species in network.equilibrium_species | sort %}
	{{network.solve_equilibrium_abundance(species.name)}}
	{% endfor %}

        mdensity = data->mdensity[threadID][i];
        inv_mdensity = 1.0 / mdensity;
        {% if "gloverabel08" in network.cooling_actions %}
        h2_optical_depth_approx = data->h2_optical_depth_approx[threadID][i];
        {% endif %}

        {% if "cie_cooling" in network.cooling_actions %}
        cie_optical_depth_approx = data->cie_optical_depth_approx[threadID][i];
        {% endif %}

        j = i * NSPARSE;
        {%- for colvals, jac_comp, s1, s2, k in network.get_sparse_matrix_component(sparse_type = "CSR", return_type="component", assign_to = "")%}
        // {{s1.name}} by {{s2.name}}
        colvals[j + {{k}}] = i * nchem + {{colvals}} ;
        matrix_data[ j + {{k}} ] {{jac_comp}}

        {% if s1.name == 'ge' %}
        matrix_data[j + {{k}}] *= inv_mdensity;
        {%- endif %}
        {%- if s2.name == 'ge' %}
        matrix_data[ j + {{k}}] *= T{{ network.energy_term.name }}[i];
        {%- endif %}
        {%- endfor %}

        {%- for rowptrs in network.get_sparse_matrix_component(sparse_type = "CSR", return_type = "indexptrs") %}
        rowptrs[ i * nchem +  {{loop.index0}}] = i * NSPARSE + {{rowptrs}};
        {%- endfor %}

        #ifdef SCALE_INPUT
        j = i * nchem;
        {%- for i1, i2, k in network.get_sparse_matrix_component(sparse_type = "CSR", return_type="index")%}
        inv_scale1 = inv_scale[ j + {{i1}} ];
        scale2     = scale    [ j + {{i2}} ];
        matrix_data[ i * NSPARSE + {{k}}]  *= inv_scale1*scale2;
        {%- endfor %}
        #endif

    }

    rowptrs[ i * nchem ] = i * NSPARSE ;
    return 0;
}

#endif
{% endblock %}


{% block setting_up_extra_variables %}
void setting_up_extra_variables( {{solver_name}}_data * data, double * input, int nstrip ){
    //-------------------------------------------------------------------------
    // Function: setting_up_extra_variables
    // Desciption: calculating variables that are independent on the state with time
    //             to avoid repeated evaluation. Examples here are h2 optical depth
    //             and cie_optical depth. Functions that depends only on density
    //-------------------------------------------------------------------------
    #ifdef _OPENMP
    int threadID = omp_get_thread_num();
    #else
    int threadID = 0;
    #endif

    int i, j;
    double mh = 1.66054e-24;
    double mdensity;
    // TODO: maybe this should be filled out by Dengo as well
    for ( i = 0; i < nstrip; i++){
        data->mdensity[threadID][i] = 0;
        j = i * {{network.ode_species | length}};
        {%- for species in network.ode_species | sort %}
        {%- if species.name not in ["ge", "de"] %}
        // species: {{species.name}}
        data->mdensity[threadID][i] += input[j] * {{species.weight}};
        {%- endif%}
        j++;
        {%- endfor%}
        // TODO: update temperature and rates to obtain abundances of equilibrium states
	// for more detail: go to the _calculate_temperature
        data->mdensity[threadID][i] *= mh;
        data->inv_mdensity[threadID][i] = 1.0 / data->mdensity[threadID][i];
    }

    {%- if "cie_cooling" in network.cooling_actions %}
    double tau;
    for ( i = 0; i < nstrip; i++){

        mdensity = data->mdensity[threadID][i];
        tau      = pow( (mdensity / 3.3e-8 ), 2.8);
        tau      = fmax( tau, 1.0e-5 );
        data->cie_optical_depth_approx[threadID][i] = fmin( 1.0, (1.0 - exp(-tau) ) / tau );
    }
    {%- endif %}

    {%- if "gloverabel08" in network.cooling_actions %}
    for ( i = 0; i < nstrip; i++ ){
        mdensity = data->mdensity[threadID][i];
        data->h2_optical_depth_approx[threadID][i] = fmin( 1.0, pow( 0.76*(mdensity / (1.336e-14) )  , -0.45) );
    }
    {%- endif %}
}
{% endblock %}


///////////////////////////////////////////////////////////////////////////////
/////////////////// Sturcture Incoming Data ///////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Reshape/ Flatten data to match the data shape/ type
// required by the solver in dengo

{% block flatten_dengo_field_data %}
int flatten_dengo_field_data(code_units *units, dengo_field_data *field_data, double *input){

    //-----------------------------------------------------
    // Function     :   flatten_dengo_field_data
    // Parameter    :
    //                  code_units: units from the incoming field_data
    //                  field_data: dengo_field_data class that contains pointer to species array
    //                  input     : 1D array that flattens the field_data,
    //                              i.e.
    //                              s = species, s0 = 0th species, with d dimensions
    //                              [s0, s1, s2..., , s0_1, s1_1, ... s0_d, s1_d, ...]
    //-----------------------------------------------------
    //
    unsigned long d, dims, i, j;
    dims = field_data->ncells;

    // code unit in terms of erg/g
    double UNIT_E_per_M = units->velocity_units * units->velocity_units;
    double m_amu = 1.66053904e-24;
    double dom = units->density_units/m_amu;
    int N = {{network.ode_species | length}};

    #pragma omp parallel for private (i, j ,d) num_threads(NTHREADS) schedule(static,1)
    for ( d = 0; d< dims; d++  ){
        j = d*N;
        // this should be the normalized
        // by the input units later
        // atol = input * rtol;
        // which again should be set by dengo
        // input in *mass density per amu*
        // and energy in the units of (erg / g)
        {%- for species in network.ode_species | sort %}
        input[j]  = field_data->{{species.name}}_density[d] ;
        {%- if species != network.energy_term %}
        input[j] *= dom;
        {%- endif %}
        {%- if species == network.energy_term %}
        input[j] *= UNIT_E_per_M;
        {%- endif %}
        j++;
        {%- endfor %}
    }
}
{% endblock flatten_dengo_field_data %}

{% block reshape_to_dengo_field_data %}
int reshape_to_dengo_field_data( code_units* units, dengo_field_data *field_data, double* input ){
    //------------------------------------------------------------------------------------
    // Function   :     reshape_to_dengo_field_data
    // Description:     reshape the 1d output array from solver to a dengo_field_data object
    //                  and covert them to code units
    //                  i.e. ge_density in erg /g
    //                       H_1_density in g / cm^-3 / amu (mass density per amu)
    // Parameter  :     code_units
    //                  dengo_field_data
    //                  input
    //------------------------------------------------------------------------------------

    unsigned long int i, j, d, dims;
    int N = {{network.ode_species | length }};
    dims = field_data->ncells; // total number of strips to be evaluated


    // code unit in terms of erg/g
    double UNIT_E_per_M = units->velocity_units * units->velocity_units;
    double m_amu = 1.66053904e-24;
    double dom = units->density_units/ m_amu;

    #pragma omp parallel for private (i, j ,d) num_threads(NTHREADS) schedule(static, 1)
    for ( d = 0; d< dims; d++  ){
        j = d*N;

        {%- for species in network.ode_species | sort %}
        field_data->{{species.name}}_density[d] = input[j];
        {%- if species != network.energy_term %}
        field_data->{{species.name}}_density[d] /= dom;
        {%- endif %}
        {%- if species == network.energy_term %}
        field_data->{{species.name}}_density[d] /= UNIT_E_per_M;
        {%- endif %}
        j++;
        {%- endfor %}
    }

    return 0;
}
{% endblock reshape_to_dengo_field_data %}


// and a enzo version
//
{% block flatten_dengo_field_data_enzo %}
int flatten_dengo_field_data_enzo(code_units *units, dengo_field_data *field_data, double *input){

    //-----------------------------------------------------
    // Function     :   flatten_dengo_field_data_enzo
    // Description  :   To read in data from Enzo pointers
    // Parameter    :
    //                  code_units: units from the incoming field_data
    //                  field_data: dengo_field_data class that contains pointer to species array
    //                  input     : 1D array that flattens the field_data,
    //                              i.e.
    //                              s = species, s0 = 0th species, with d dimensions
    //                              [s0, s1, s2..., , s0_1, s1_1, ... s0_d, s1_d, ...]
    //                              abundances in units of mass density / m_amu
    //                              m_amu is in atomic mass units
    //-----------------------------------------------------
    //

    int is, ie, js, je, ks, ke;
    int i, j, k, N;
    int ni, nj, nk, idim, jdim, kdim;
    unsigned long dims, ccount, c, idx;

    N = {{network.ode_species | length}};
    // avoid ghost zones
    is = field_data->grid_start[0];
    ie = field_data->grid_end[0];

    js = field_data->grid_start[1];
    je = field_data->grid_end[1];

    ks = field_data->grid_start[2];
    ke = field_data->grid_end[2];

    idim = field_data->grid_dimension[0];
    jdim = field_data->grid_dimension[1];
    kdim = field_data->grid_dimension[2];

    // number of cells that actually required calculations
    ni = ie - is + 1;
    nj = je - js + 1;
    nk = ke - ks + 1;
    dims = ni*nj*nk;
    field_data->ncells = dims;

    // code unit in terms of erg/g
    double UNIT_E_per_M = units->velocity_units * units->velocity_units;
    double m_amu = 1.66053904e-24;
    double dom = units->density_units/m_amu;


    ccount = 0;
    for (k = ks; k <= ke; k++){
    for (j = js; j <= je; j++){
    for (i = is; i <= ie; i++){
        c = ccount * N;
	    idx = ((k* jdim + j)*idim + i);

        {%- for species in network.ode_species | sort %}
        input[c]  = field_data->{{species.name}}_density[idx];
        {%- if species != network.energy_term %}
        input[c] *= dom;
        {%- endif %}
        {%- if species == network.energy_term %}
        input[c] *= UNIT_E_per_M;
        {%- endif %}
        c++;
        {%- endfor %}
        ccount += 1;

        }}}
    // convert to number density now before evolve
    for (i = 0; i < dims; i++) {
        j = i * N;
        {%- for species in network.ode_species | sort %}
        {%- if species.name != "ge" %}
        input[j] /= {{species.weight}}; // {{species.name}}
        {%- endif%}
        j++;
        {%- endfor%}
    }
    return 0;
}
{% endblock flatten_dengo_field_data_enzo %}

{% block reshape_to_dengo_field_data_enzo %}
int reshape_to_dengo_field_data_enzo( code_units* units, dengo_field_data *field_data, double* input, double *temp ){
    //------------------------------------------------------------------------------------
    // Function   :     reshape_to_dengo_field_data
    // Description:     reshape the 1d output array from solver to a dengo_field_data object
    //                  and covert them to code units
    //                  i.e. ge_density in erg /g
    //                       H_1_density in g / cm^-3 / amu (mass density per amu)
    // Parameter  :     code_units
    //                  dengo_field_data
    //                  input
    //------------------------------------------------------------------------------------

    unsigned long i, j, k, d;
    unsigned long idx, ccount, c,dims;
    int is, ie, js, je, ks, ke;
    int ni, nj,nk;
    int N = {{network.ode_species | length }};

    is = field_data->grid_start[0];
    ie = field_data->grid_end[0];

    js = field_data->grid_start[1];
    je = field_data->grid_end[1];

    ks = field_data->grid_start[2];
    ke = field_data->grid_end[2];

    int idim = field_data->grid_dimension[0];
    int jdim = field_data->grid_dimension[1];
    int kdim = field_data->grid_dimension[2];

    ni = ie - is + 1;
    nj = je - js + 1;
    nk = ke - ks + 1;
    dims = ni*nj*nk;
    field_data->ncells = dims;
    dims = field_data->ncells; // total number of strips to be evaluated

    // code unit in terms of erg/g
    double UNIT_E_per_M = units->velocity_units * units->velocity_units;
    double m_amu = 1.66053904e-24;
    double dom = units->density_units/ m_amu;

    // extra bits for calculating  conservation
    {%- if network.enforce_conservation %}
    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}
    int nchem = {{network.ode_species|length}};
    // should be exported from dengo
    double fH = 0.76;
    double fHe = 1.0 - fH;
    {%- for s in network.get_conserved_dict()%}
    double total_{{s}}[dims];
    {%- endfor %}
    {%- for species in network.equilibrium_species | sort %}
    double *{{species.name}}_arr = &temp[{{loop.index}}*dims];
    {%- endfor %}
    double *density = field_data->density;
    ////////////////////////////////////////////
    // first pass to fill out the total_H and total_He;
    for (i = 0; i<dims; i++) {
        j = i * nchem;
        {%- for species in network.ode_species | sort %}
        {{species.name}} = input[j];
        j++;
        {%- endfor-%}

	    {%- for species in network.equilibrium_species | sort %}
        {{species.name}} = {{species.name}}_arr[i] * {{species.weight}};
        {%- endfor %}

        // calculate totalH and totalHe
        {%- for s in ["H", "He"] %}
        {{network.print_conserved_species(s, "total_{}[i]".format(s), is_mass_density=True)}}
        {%-endfor%}
    }
    {%- endif %}
    ////////////////////////////////////////////
    ccount = 0;
    for (k = ks; k <= ke; k++){
    for (j = js; j <= je; j++){
    for (i = is; i <= ie; i++){
        c = ccount * N;
	    idx = ((k* jdim + j)*idim + i);

	    {%- for species in network.equilibrium_species | sort %}
        field_data->{{species.name}}_density[idx] = {{species.name}}_arr[ccount];
        field_data->{{species.name}}_density[idx] /= dom;
        {%- endfor %}

        {%- for species in network.ode_species | sort %}
        field_data->{{species.name}}_density[idx] = input[c];
        {%- if species != network.energy_term %}
        field_data->{{species.name}}_density[idx] /= dom;
        {%- endif %}
        {%- if species == network.energy_term %}
        field_data->{{species.name}}_density[idx] /= UNIT_E_per_M;
        {%- endif %}
        c++;
        {%- endfor %}
        ccount += 1;
    }}}

    {%- if network.enforce_conservation %}
    ///////////////////////////////////////////////
    // And another pass that apply conservation
    ///////////////////////////////////////////////
    double rho;
    ccount = 0;
    for (k = ks; k <= ke; k++){
    for (j = js; j <= je; j++){
    for (i = is; i <= ie; i++){
        c = ccount * N;
	    idx = ((k* jdim + j)*idim + i);
	    rho = density[idx]*units->density_units/m_amu; // density in cgs units
	    // given a speices, return the element it belongs to
        {%- for species in network.ode_species | sort %}
        // {{species.name}}
	    {%- for element in species.elements %}
	    field_data->{{species.name}}_density[idx] *= f{{element}}*rho/total_{{element}}[ccount];
	    {%- endfor %}
        {%- endfor %}
	    //fprintf(stderr, "fractional difference: %0.5g\n", fH*rho/total_H[ccount]);
	    ccount += 1;
    }}}
    {%- endif %}

    return 0;
}
{% endblock reshape_to_dengo_field_data_enzo %}


{% block read_init_data_to_dengo %}
int read_init_data_to_dengo( dengo_field_data *field_data, char const *filename){

    // this reads the initial abundances of the data from
    // a hdf5 file, and initialize a field_data object

    hid_t file_id = H5Fopen(filename, H5F_ACC_RDONLY, H5P_DEFAULT);

    if (file_id < 0){
        fprintf(stderr, "failed to open %s so dying. \n", filename);
        return (1);
        }

    hsize_t dims;
    /* Check gas energy to get the number of cells */
    fprintf(stderr, "Getting dimensionality from ge:\n");
    herr_t status = H5LTget_dataset_info(file_id, "/ge", &dims, NULL, NULL);
    if(status == -1) {
        fprintf(stderr, "Error opening initial conditions file.\n");
        return 1;
    }
    fprintf(stderr, "  ncells = % 3i\n", (int) dims);

    field_data->ncells = (int) dims;
    int N = {{network.required_species | length }};
    double *atol, *rtol;
    atol = (double *) malloc(N * dims * sizeof(double));
    rtol = (double *) malloc(N * dims * sizeof(double));

    double *tics = (double *) malloc(dims * sizeof(double));
    double *ics = (double *) malloc(dims * N * sizeof(double));
    double *input = (double *) malloc(dims * N * sizeof(double));

    unsigned int i = 0, j;

    {%- for species in network.required_species | sort %}
    double *{{species.name}} = (double *) malloc(dims * sizeof(double));
    field_data->{{species.name}}_density = {{species.name}};
    {% endfor %}

    {%- for species in network.required_species | sort %}
    fprintf(stderr, "Reading I.C. for /{{species.name}}\n");
    H5LTread_dataset_double(file_id, "/{{species.name}}", tics);
    for ( j = 0; j < dims; j++ ){
        field_data->{{species.name}}_density[j] = tics[j];
        if (j == 0){
            fprintf(stderr, "{{species.name}}[0] = %0.3g \n", tics[j] );
        }
    }
    i++;
    {% endfor %}

    H5Fclose(file_id);
    free(input);
    free(ics);
    return 1;
}

{% endblock %}
