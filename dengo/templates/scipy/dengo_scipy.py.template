import numpy as np
import h5py

mh      = 1.67e-24
kb      = 1.38e-16
gamma   = 5./3.
gammaH2_1 = 7./5.
gammaH2_2 = 7./5.
_gamma_m1 = 1./ (gamma-1.)

# read rates in as global variables
rates_table = 'reaction_rates.h5'
ratef = h5py.File(rates_table, 'r')

# Reaction Rates
{% for k in network.reactions.keys()%}
out{{k}}dev = ratef['{{k}}'][:]
{%- endfor %} 

# Cooling Rates
{%- for name, rate in network.cooling_actions | dictsort %}
{%- for name2 in rate.tables | sort %}
out_{{name}}_{{name2}} = ratef["{{name}}_{{name2}}"][:]
{%- endfor %}
{%- endfor %}
tdev = ratef['T'][:]
ratef.close()

def interpolate_rates(T):
    """Interpolate all the reaction rates based on temperature
    """
    {% for k in network.reactions.keys()%}
    {{k}} = np.interp(T, tdev, out{{k}}dev)
    {%- endfor %} 
    return (
    {%- for k in network.reactions.keys() -%}
    {{k}}, 
    {%- endfor -%}
    )
def interpolate_cooling_rates(T):
    """Interpolate all the cooling rates based on temperature
    """
    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    {{name}}_{{name2}} = np.interp(T, tdev, out_{{name}}_{{name2}})
    {%- endfor %}
    {%- endfor %}
    return (
    {%- for name, rate in network.cooling_actions | dictsort -%}
    {%- for name2 in rate.tables | sort -%}
    {{name}}_{{name2}}, 
    {%- endfor -%}
    {%- endfor -%}
    )

def calculate_temperature(state):
    """calculate temperature based on the N different input state

    Parameters
    ----------
    state : ndarray with shape [NSPECIES + 1, N]
    Abundances sorted by name, and the last dimension corresponds to the current check_time

    Returns
    -------
    Temperature: ndarray

    """
# retreive the species 
    {% for s in network.required_species | sort -%}
    {{s.name}}, 
    {%- endfor -%}
    _= state


    density = {{network.print_mass_density()}}

    return {{network.temperature_calculation()}}



def f(state):
    """RHS function of each chemical species

    Parameters
    ----------
    state : ndarray with shape [NSPECIES + 1, N]
    Abundances sorted by name, and the last dimension corresponds to the current check_time

    Returns
    -------
    dy/dt: rate of change of each species
    """

# retreive the species 
    {% for s in network.required_species | sort -%}
    {{s.name}}, 
    {%- endfor -%}
    current_time= state

# calculate temperature
    T = calculate_temperature(state)
    
# calculate mass density
    mdensity = {{network.print_mass_density()}}*mh;
    inv_mdensity = 1/mdensity;
        
# calculate the h2 optical depth approximation        
    h2_optical_depth_approx  = min( 1.0, pow( (mdensity / (1.34e-14) )  , -0.45) );
    
    tau      = pow( (mdensity / 3.3e-8 ), 2.8);
    tau      = max( tau, 1.0e-5 );
    cie_optical_depth_approx = min( 1.0, (1.0 - exp(-tau) ) / tau );

# interpolate the rates
    {% for k in network.reactions.keys() -%}
    {{k}}, 
    {%- endfor %} = interpolate_rates(T)

    
    {% for name, rate in network.cooling_actions | dictsort -%}
    {%- for name2 in rate.tables | sort -%}
    {{name}}_{{name2}}, 
    {%- endfor -%}
    {%- endfor -%} = interpolate_cooling_rates(T)

# rhs function
    {% for s in network.required_species | sort %}
    d{{s.name}} = {{rhs_dict[s]}}*np.ones_like(ge)
    {%- endfor %} 

    return np.array([
    {%- for s in network.required_species | sort -%}
    d{{s.name}}, 
    {%- endfor -%}
    0.0*current_time
    ])


def Jac(state):
    """Jacobian function of each chemical species

    Parameters
    ----------
    state : ndarray with shape [NSPECIES + 1, N]
    Abundances sorted by name, and the last dimension corresponds to the current check_time

    Returns
    -------
    Jacobian Matrix [NSPECIES, NSPECIES]
    """
    jac = np.zeros({{network.required_species | length}}, {{network.required_species | length}})

    # retreive the species 
    {% for s in network.required_species | sort -%}
    {{s.name}}, 
    {%- endfor -%}
    current_time= state

    # calculate temperature
    T = calculate_temperature(state)

    # interpolate the rates
    {% for k in network.reactions.keys() -%}
    {{k}}, 
    {%- endfor %} = interpolate_rates(T)

    
    {% for name, rate in network.cooling_actions | dictsort -%}
    {%- for name2 in rate.tables | sort -%}
    {{name}}_{{name2}}, 
    {%- endfor -%}
    {%- endfor -%} = interpolate_cooling_rates(T)

    mdensity = {{network.print_mass_density()}};
    inv_mdensity = 1/mdensity;

    {%- for s2 in network.ode_species | sort %}
    # Species: {{s2.name}}
    {% set i_s2 = loop %}
    {%- for s1 in network.ode_species | sort %}
    {% set i_s1 = loop%}
    # {{s2.name}} by {{s1.name}}
    {{ network.print_jacobian_component(s2, s1, assign_to="jac[{0},{1}]".format( i_s2.index0, i_s1.index0 ) , print_zeros = True) }}

    {%- if s2.name == 'ge' %}
    jac[{{i_s2.index0}}, {{i_s1.index0}}] *= inv_mdensity;
    {%- endif %}
    
    {%- if s1.name == 'ge' %}
    jac[{{i_s2.index0}}, {{i_s1.index0}}] *= 0.0
    {%- endif %}

    {%- endfor %}
    {%- endfor %}
    
    return jac


