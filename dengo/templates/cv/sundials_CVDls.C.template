{% block solver_comment_header %}
/* THIS FILE HAS BEEN AUTO-GENERATED.  DO NOT EDIT. */

/* This is C++ code to read HDF5 files for
   reaction rates, cooling rates, and initial
   conditions for the chemical network defined
   by the user.  In addition, this contains
   code for calculating temperature from the
   gas energy and computing the RHS and the
   Jacobian of the system of equations which
   will be fed into the solver.
*/
{% endblock %}

#include "{{solver_name}}_solver.h"

{{solver_name}}_data *{{solver_name}}_setup_data(
    int *NumberOfFields, char ***FieldNames)
{   
    //-----------------------------------------------------
    // Function : {{solver_name}}_setup_data
    // Description: Initialize a data object that stores the reaction/ cooling rate data 
    //-----------------------------------------------------

    int i;

    {{solver_name}}_data *data = ({{solver_name}}_data *) malloc(sizeof({{solver_name}}_data));
    
    /* allocate space for the scale related pieces */
    for (i = 0; i< {{network.required_species | length}} ; i++){
        data->scale[i] = 1.0;
        data->inv_scale[i] = 1.0;
    }
    
    data->nstrip = MAX_NCELLS;
    /*initialize temperature so it wont crash*/
    for ( i = 0; i < MAX_NCELLS; i++ ){
        data->Ts[i] = 1000.0;
        data->logTs[i] = log(1000.0);
    }

    /* Temperature-related pieces */
    data->bounds[0] = {{ network.T_bounds[0] }};
    data->bounds[1] = {{ network.T_bounds[1] }};
    data->nbins = {{ network.T | length }} - 1;
    data->dbin = (log(data->bounds[1]) - log(data->bounds[0])) / data->nbins;
    data->idbin = 1.0L / data->dbin;

    /* Redshift-related pieces */
    data->z_bounds[0] = {{ network.z_bounds[0] }};
    data->z_bounds[1] = {{ network.z_bounds[1] }};
    data->n_zbins = {{ network.z | length }} - 1;
    data->d_zbin = (log(data->z_bounds[1] + 1.0) - log(data->z_bounds[0] + 1.0)) / data->n_zbins;
    data->id_zbin = 1.0L / data->d_zbin;
    
    {{ solver_name }}_read_rate_tables(data);
    fprintf(stderr, "Successfully read in rate tables.\n");

    {{ solver_name }}_read_cooling_tables(data);
    fprintf(stderr, "Successfully read in cooling rate tables.\n");
    
    {{ solver_name }}_read_gamma(data);
    fprintf(stderr, "Successfully read in gamma tables. \n");

    if (FieldNames != NULL && NumberOfFields != NULL) {
        NumberOfFields[0] = {{network.required_species | length}};
        FieldNames[0] = new char*[{{ network.required_species | length }}];
        i = 0;
        {% for s in network.required_species | sort %}
        FieldNames[0][i++] = strdup("{{s.name}}");
        {% endfor %}
    }
    return data;

}

{% block entry_point %}
int {{solver_name}}_main(int argc, char** argv )
{   
    //-----------------------------------------------------
    // Function : {{solver_name}}_main
    // Description: this will look for initial condition files from the CLI, 
    //              evolve the ODE system to dtf specified from the CLI, (if not it's set to freefall time),
    //              and write the result to {{solver_name}}_solution.h5 if output file name is not specified
    // Parameter:   argv[1]   : initial condition file name (in hdf5 format)
    //              argv[2]   : output file name (in hdf5 format)
    //              argv[3]   : desired final time reached by solver (in seconds)
    //
    // Note:        Units of initial conditions/ output 
    //              Baryons: mass density in a.m.u * cm^-3 ( 1mH = 1.00794 amu )
    //              de     : number density of electrons in cm^-3 
    //              ge     : internal energy per mass density of the cell (erg / g )
    //-----------------------------------------------------
    {{ solver_name }}_data *data = {{solver_name}}_setup_data(NULL, NULL);

    /* Reading Initial conditions */
    hid_t file_id;
    if (argc < 2){
    file_id = H5Fopen("{{ solver_name }}_initial_conditions.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
    if (file_id < 0) {fprintf(stderr, "Failed to open "
        "{{ solver_name }}_initial_conditions.h5 so dying.\n");
        return(1);}
    } else {
        file_id = H5Fopen( argv[1], H5F_ACC_RDONLY, H5P_DEFAULT);
        if (file_id < 0) {fprintf(stderr, "Failed to open  your initial_conditions file so dying.\n");
        return(1);}
       
            
    }

    /* Allocate the correct number of cells */
    hsize_t dims; /* We have flat versus number of species */

    /* Check gas energy to get the number of cells */
    fprintf(stderr, "Getting dimensionality from {{ network.energy_term.name }}:\n");
    herr_t status = H5LTget_dataset_info(file_id, "/{{ network.energy_term.name }}", &dims, NULL, NULL);
    if(status == -1) {
        fprintf(stderr, "Error opening initial conditions file.\n");
        return 1;
    }
    fprintf(stderr, "  ncells = % 3i\n", (int) dims);
    data->ncells = dims;

    int N = {{network.required_species | length}};

    double *atol, *rtol;
    atol = (double *) malloc(N * dims * sizeof(double));
    rtol = (double *) malloc(N * dims * sizeof(double));

    double *tics = (double *) malloc(dims * sizeof(double));
    double *ics = (double *) malloc(dims * N * sizeof(double));
    double *input = (double *) malloc(dims * N * sizeof(double));
    double *temp  = (double *) malloc(dims * sizeof(double) );

    unsigned int i = 0, j;
    {% for s in network.required_species | sort %}
    fprintf(stderr, "Reading I.C. for /{{ s.name }}\n");
    H5LTread_dataset_double(file_id, "/{{ s.name }}", tics);
    for (j = 0; j < dims; j++) {
        ics[j * N + i] = tics[j]; 
        atol[j * N + i] = tics[j] * 1e-09;
        rtol[j * N + i] = 1e-09;
        if(j==0) {
            fprintf(stderr, "{{s.name}}[0] = %0.3g, atol => % 0.16g\n",
                    tics[j], atol[j]);
        }
    }
    i++;
    {% endfor %}
    
    double *density = (double *) malloc(dims *sizeof(double) );
    H5LTread_dataset_double(file_id, "/density", density);

    H5Fclose(file_id);
    
    //
    // Use free fall time, not the time specified by 
    // the network itself
    double dtf, t0;
    t0 = 2.992e15;
    dtf = t0 / sqrt(density[0]);
    
    // if the output time is specified,
    // it overrides the freefall time
    if (argc > 3){
        dtf = atof( argv[3] ); 
    }

    double dt = -1.0;
    double z = -1.0;
    for (i = 0; i < dims * N; i++) input[i] = ics[i];
    double ttot;
    int flag = dengo_evolve_{{solver_name}}(dtf, dt, z, input, rtol, atol, dims, data, temp);
    if (flag > 0){
        fprintf(stderr, "solver failed, Time reached by the solver: %0.5g \n", dt);    
    }

    /* Write results to HDF5 file */

    if (argc < 3){
        file_id = H5Fcreate("{{ solver_name }}_solution.h5", H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
    } else{
        file_id = H5Fcreate( argv[2], H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
    }

    hsize_t dimsarr[1];
    dimsarr[0] = dims;
    i = 0;
    {% for s in network.required_species | sort %}
    double {{ s.name }}[dims];
    for (j = 0; j < dims; j++) {
        {{ s.name }}[j] = input[j * N + i]; 
    }
    fprintf(stderr, "Writing solution for /{{ s.name }}\n");
    H5LTmake_dataset_double(file_id, "/{{ s.name }}", 1, dimsarr, {{ s.name }});
    i++;
    {% endfor %}


    H5LTmake_dataset_double(file_id, "/T", 1, dimsarr, temp);

    double time[1];
    time[0] = ttot;
    double timestep[1];
    timestep[0] = dt;
    H5LTset_attribute_double(file_id, "/", "time", time, 1); 
    H5LTset_attribute_double(file_id, "/", "timestep", timestep, 1);
    H5Fclose(file_id);
    
    free(temp);
    free(tics);
    free(ics);
    free(data);
    free(rtol);
    free(atol);
    free(input);
    free(density);

    return 0;
}
{% endblock %} {# entry_point #}

{% block main_evolution %}

int dengo_evolve_{{solver_name}} (double dtf, double &dt, double z, double *input,
            double *rtol, double *atol, long long dims, {{solver_name}}_data *data, double *temp_array ) {
    //-----------------------------------------------------
    // Function     : dengo_evolve_{{solver_name}}
    // Description  : Main ODE solver function in dengo
    
    // Parameter    :   dtf     : Desired time to be reached by the solver
    //                  dt      : Pointer to the actual time reached by the solver
    //                  z       : Current redshift
    //                  input   : Array to store the initial value of each species, 
    //                            it will be updated with the value at time dt
    //                  rtol    : relative tolerance required for convergenece in each internal CVODE timesteps
    //                  atol    : absolute tolerance required for convergence in each interanl CVODE timesteps
    //                  dims    : dimension of the input array, i.e. no. of species * no. of cells
    //                  data    : {{solver_name}}_data object that relay the reaction/cooling rates, and normalizations 
    //                  temp_array: temperature of each cell by the end of the evolution
    //                           
    //-----------------------------------------------------
    int i, j;
    hid_t file_id;
    int N = {{network.required_species | length}};

    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {% endfor %}
    

    {%- if not network.input_is_number %}
    for (i = 0; i < dims; i++) {
        j = i * N;
        {%- for species in network.required_species | sort %}
        {%if species.name != "ge" %}
        {{species.name}} = input[j] /= {{species.weight}};
        {%endif%}
        j++;
        {%endfor%}
    }
    {%- endif %}
    //ensure_electron_consistency(input, dims, N);

    rhs_f f = calculate_rhs_{{solver_name}};

    #ifndef CVSPILS
    #ifdef  CVKLU
    jac_f jf = calculate_sparse_jacobian_{{solver_name}};
    #else
    jac_f jf = calculate_jacobian_{{solver_name}};
    #endif
    #endif
    
    #ifdef CVSPILS
    jac_f jf = calculate_JacTimesVec_{{solver_name}};
    #endif

    if (dt < 0) dt = dtf / 1e0;
    data->current_z = z;
    int niter = 0;
    int siter = 0;
    double ttot = 0;
    double *ttot_all = (double *) malloc( dims * sizeof(double) );

    double floor_value = 1e-25;

    // Initialize a CVODE object, memory spaces
    // and attach rhs, jac to them
    int flag;
    double reltol = 1.0e-4;
    void *cvode_mem;
    int MAX_ITERATION = 1000;
    double mh = 1.67e-24;
    int nstrip = data->nstrip;

    SUNLinearSolver LS;
    SUNMatrix A;
    N_Vector y_vec, abstol;

    // inputs are now grouped into a batch of nstrip
    // and send into the CVode solver
    //
    // ntimes: the number of times the CVode solver will be called
    // v_size: the size of the input vector for the solver
    //       : v_size = N * nstrip
    // v_size_res: leftover strip that doesn't fit into a v_size batch
    // N     : Number of species

    int v_size     = N * nstrip;
    int ntimes     = dims / nstrip;

    int nstrip_res = dims % nstrip;
    int v_size_res = N * nstrip_res;

    double y[dims];
    
    y_vec = NULL;   
    LS = NULL;
    A  = NULL;
    
    y_vec  = N_VNew_Serial( v_size );
    abstol = N_VNew_Serial( v_size ); 

    for (i = 0; i < v_size ; i++) {
        NV_Ith_S(y_vec ,i)   = 1.0;
        NV_Ith_S(abstol,i)   = reltol*reltol;
    }
    
    #ifdef CVKLU
    A         = SUNSparseMatrix      ( v_size, v_size, nstrip * 64, CSR_MAT );
    LS        = SUNKLU( y_vec, A);
    #else
    A         = SUNDenseMatrix      ( v_size, v_size );
    LS        = SUNDenseLinearSolver( y_vec, A);
    #endif
    
    cvode_mem = setup_cvode_solver  ( f, jf, v_size , data, LS, A, y_vec, reltol, abstol);
    
    int d;
    // d: the d th patch going into the solver
    for (d = 0; d < ntimes; d++){

        ttot = evolve_in_batches( cvode_mem, y_vec, abstol, reltol, input, v_size, d, d*v_size, MAX_ITERATION, dtf, data );
        // re-calculate temperature at the final output
        {{solver_name}}_calculate_temperature(data, data->scale, nstrip, N);
        for ( i = 0; i < nstrip; i ++){
            ttot_all  [ d * nstrip + i ] = ttot;
            temp_array[ d * nstrip + i ] = data->Ts[i];
        }
        fprintf(stderr, "%d the strip = %0.5g\n", d, ttot);
        // copy data back to the input array
        for (i = 0; i < v_size; i++){
            input     [ d * v_size + i ] = data->scale[i] ;
        } 
    } // for d dims loop
    
    if ( v_size_res > 0 ){

        data->nstrip = nstrip_res;
        d = ntimes;
        
        // free all unused memory;
        CVodeFree(&cvode_mem);
        SUNLinSolFree(LS);
        SUNMatDestroy(A);
        N_VDestroy(y_vec);
        N_VDestroy(abstol);
       
        SUNLinearSolver LS;
        SUNMatrix A;
        N_Vector y_vec, abstol;
     
        y_vec = NULL;   
        LS = NULL;
        A  = NULL;
    
        y_vec  = N_VNew_Serial( v_size_res );
        abstol = N_VNew_Serial( v_size_res ); 

        for (i = 0; i < v_size_res; i++) {
            NV_Ith_S(y_vec ,i)   = 1.0;
            NV_Ith_S(abstol,i)   = reltol*reltol;
        }
       
        #ifdef CVKLU
        A  = SUNSparseMatrix(v_size_res, v_size_res, nstrip_res * 64, CSR_MAT);
        LS = SUNKLU(y_vec,A); 
        #else
        A  = SUNDenseMatrix(v_size_res, v_size_res);
        LS = SUNDenseLinearSolver(y_vec, A);
        #endif
        
        cvode_mem = setup_cvode_solver( f, jf, v_size_res, data, LS, A, y_vec, reltol, abstol );
        ttot = evolve_in_batches(cvode_mem, y_vec, abstol, reltol, input, v_size_res, d, d * v_size,  MAX_ITERATION, dtf, data);
        {{solver_name}}_calculate_temperature(data, data->scale, nstrip, N);
        for ( i = 0; i < nstrip; i ++){
            ttot_all  [ d * nstrip + i ] = ttot;
            temp_array[ d * nstrip + i ] = data->Ts[i];
        }
       
        fprintf(stderr, "%d the strip = %0.5g\n", d, ttot);
        // copy data back to the input array
        for (i = 0; i < v_size_res; i++){
            input     [ d * v_size + i ] = data->scale[i] ;
        } 
        // free all unused memory;
        CVodeFree(&cvode_mem);
        SUNLinSolFree(LS);
        SUNMatDestroy(A);
        N_VDestroy(y_vec);
        N_VDestroy(abstol);
    }
    


    {%-  if not network.input_is_number %}
    for (i = 0; i < dims; i++) {
      j = i * N;
      {%- for species in network.required_species | sort %}
      {%if species.name != "ge" %}
      {{species.name}} = input[j];
      input[j] *= {{species.weight}};
      {%endif%}
      j++;
      {%endfor%}
    }
    {%- endif %}

    double dt_final = dtf;
    
    for (int d = 0; d < dims; d++){
        if (ttot_all[d] < dt_final) dt_final = ttot_all[d];    
    }
    fprintf(stderr, "Fraction of completion (dt / dtf): %0.5g\n", dt_final/dtf);
    free(ttot_all);

    dt = dt_final;

    if (dt_final < dtf) return 1;
    
    return 0;
}
{% endblock %} {# main_evolution #}


{% block evolve_in_batches %}

double evolve_in_batches( void * cvode_mem, N_Vector y_vec, N_Vector abstol,  
                          double reltol,double *input, int v_size, int d, int start_idx, 
                          int MAX_ITERATION, double dtf, {{solver_name}}_data *data ){ 
    // Function   :     evolve_in_batches
    // Description:     this would evolve the ODE system in bataches of size v_size
    //                  and return the final time reached by the solver
    //
    // Parameter  :     cvode_mem   : CVODE memory object
    //                  y_vec           : Array to store/relay the data to the CVODE solver                  
    //                  abstol          : Array of absolute tolerance for each internal timestep
    //                  reltol          : Relative tolerance requested for each internal timestep
    //                  input           : Array to store the input number density/ energy of the species
    //                  v_size          : Size of the ODE system, i.e. No. of Species * No. of Strips/cells
    //                  d               : Batch count
    //                  start_idx       : Index to the first element from "input" for the current batch
    //                  MAX_ITERATION   : Maximum Call/retry to the CVODE solver
    //                  dtf             : Desired final output time
    //                  data            : {{solver_name}}_data object that stores rate/ temperature/ scale data
    // Return    :      ttot            : final time reached by the solver

    int i, siter, flag;
    double dt, ttot;
    double y[v_size];
    int nstrip = data->nstrip;

    for (i = 0; i < v_size; i++){ 
        data->scale[i]         = input[ start_idx + i];
        data->inv_scale[i]     = 1.0 / data->scale[i];
        NV_Ith_S(y_vec , i )   = 1.0;
        NV_Ith_S(abstol, i )   = reltol*reltol;
    }
    
    fprintf(stderr, "incoming strip size: %d \n", nstrip);
    setting_up_extra_variables(data, data->scale, nstrip );
        
    // initialize a dt for the solver  
    dt = dtf;
    ttot = 0.0;
    siter = 0;
            
    while (ttot < dtf) { 
        fprintf(stderr, "%d th strip: %d iterations, time: %0.5g\n", d, siter, ttot );    
        flag = cvode_solver( cvode_mem, y, v_size , &dt, data, y_vec, reltol, abstol);

        for (i = 0; i < v_size; i++) {
            if (y[i] < 0) {
                fprintf(stderr, "negative \n");
                flag = 1;
                break;
            }
        }
            
        for (i = 0; i < v_size ; i++){
            NV_Ith_S(y_vec , i )   = 1.0;
            NV_Ith_S(abstol, i )   = reltol*reltol;   
        }

        if (flag < 1){
        // flag = 0 => success
        // we reset the scale of each component 
        // with the solution returned by the solver
        for (i = 0; i < v_size; i++){
            data->scale[i] = y[i] * data->scale[i];
            data->inv_scale[i] = 1.0/ data->scale[i];
        }

        ttot += dt;
        dt = DMIN(dt * 2.0, dtf - ttot);
        } else{
            dt /= 2.0;
            dt = DMIN(dt , dtf - ttot);
        }
        if (siter == MAX_ITERATION) break;
        siter++;
        } // while loop for each strip
    
    return ttot;
}
{% endblock evolve_in_batches%}



{% block read_tables %}
void {{ solver_name }}_read_rate_tables({{solver_name}}_data *data)
{
    hid_t file_id = H5Fopen("{{ solver_name }}_tables.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
    /* Allocate the correct number of rate tables */
    
    {%- for name, rate in network.reactions | dictsort %}
    H5LTread_dataset_double(file_id, "/{{ name }}", data->r_{{name}});
    {%- endfor %}
    
    H5Fclose(file_id);
}


void {{ solver_name }}_read_cooling_tables({{solver_name}}_data *data)
{

    hid_t file_id = H5Fopen("{{ solver_name }}_tables.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
    /* Allocate the correct number of rate tables */

    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    H5LTread_dataset_double(file_id, "/{{name}}_{{name2}}",
                            data->c_{{name}}_{{name2}});
    {%- endfor %}
    {%- endfor %}

    H5Fclose(file_id);
}

void {{ solver_name }}_read_gamma({{solver_name}}_data *data)
{

    hid_t file_id = H5Fopen("{{ solver_name }}_tables.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
    /* Allocate the correct number of rate tables */
    

    {%- for sp in network.interpolate_gamma_species_name | sort %}
    H5LTread_dataset_double(file_id, "/gamma{{sp}}",
                            data->g_gamma{{sp}} );
    H5LTread_dataset_double(file_id, "/dgamma{{sp}}_dT",
                            data->g_dgamma{{sp}}_dT );   
    {% endfor %}

    H5Fclose(file_id);

}
{% endblock %} {# read_tables #}

{% block calculate_temperature %}
int {{ solver_name }}_calculate_temperature({{ solver_name }}_data *data,
                        double *input, int nstrip, int nchem)
{
    int i, j;
    double density, T, Tnew;
    double kb = 1.3806504e-16; // Boltzmann constant [erg/K]
    double mh = 1.67e-24;
    double gamma = 5.e0/3.e0;
    double _gamma_m1 = 1.0 / (gamma - 1);

    {% if 'H2_1' in network.species_list() %}
    double gammaH2 = 7.e0/5.e0; // Should be a function of temperature
    	   	     		// this is a temporary solution
    double dge_dT;
    double dge;

    {% for sp in network.interpolate_gamma_species_name | sort %}
    double gamma{{sp}};
    double dgamma{{sp}}_dT;
    double _gamma{{sp}}_m1;
    {% endfor %}
        
    double Tdiff = 1.0;
    int MAX_T_ITERATION = 100;
    int count = 0;

    {% endif %}

    
    
    /* Calculate total density */

    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}
    
    
    i = 0;

    for ( i = 0; i < nstrip; i++ ){
        j = i * nchem;
    
        {%- for species in network.required_species | sort %}
        {{species.name}} = input[j];
        j++;
        {% endfor %}
        
        {% if network.include_binding_energy == 1%}       
        ge += 7.177e-12 * ( 0.5* H2_1 + 0.5* H2_2 ) ;
        ge -= 7.177e-12 * ( H_1 + H_2 );
        {% endif %}

        density = {{network.print_mass_density()}};
        
    
        {% if 'H2_1' in network.species_list() %}
        
        // Initiate the "guess" temperature
        T    = data->Ts[i];
        Tnew = T*1.1;
        
        Tdiff = Tnew - T;
        count = 0;

        while ( Tdiff/ Tnew > 0.001 ){
            // We do Newton's Iteration to calculate the temperature
            // Since gammaH2 is dependent on the temperature too!

            T = data->Ts[i];
        
            {{ solver_name }}_interpolate_gamma(data, i);
            {% for sp in network.interpolate_gamma_species_name | sort %}
            gamma{{sp}} = data->gamma{{sp}}[i];
            dgamma{{sp}}_dT = data->dgamma{{sp}}_dT[i];
            _gamma{{sp}}_m1 = 1.0 / (gamma{{sp}} - 1.0);
            // fprintf(stderr, ":gamma{{sp}} %0.5g , dgamma{{sp}}_dT: %.5g \n", gamma{{sp}}, dgamma{{sp}}_dT  );
            {% endfor %}
       
        
            // update gammaH2
            // The derivatives of  sum (nkT/(gamma - 1)/mh/density) - ge
            // This is the function we want to minimize
            // which should only be dependent on the first part
            dge_dT = {{network.temperature_calculation(derivative_dge_dT=True)}};
        
            //This is the change in ge for each iteration
            dge = {{network.temperature_calculation(get_dge=True)}};

            Tnew = T - dge/dge_dT;
            data->Ts[i] = Tnew;
        
            Tdiff = fabs(T - Tnew);
            // fprintf(stderr, "T: %0.5g ; Tnew: %0.5g; dge_dT: %.5g, dge: %.5g, ge: %.5g \n", T,Tnew, dge_dT, dge, ge);
            count += 1;
            if (count > MAX_T_ITERATION){
                fprintf(stderr, "T failed to converge \n");
                return 1;
            }
        } // while loop
    
        data->Ts[i] = Tnew;


        // fprintf(stderr,"T : %0.5g, density : %0.5g, d_gammaH2: %0.5g \n", Tnew, density, gammaH2 - 7./5.);


        {% else %} {# if 'H2_1' in network.species_list() #}
        data->Ts[i] = {{network.temperature_calculation()}};
        {% endif %}

        if (data->Ts[i] < data->bounds[0]) {
            data->Ts[i] = data->bounds[0];
        } else if (data->Ts[i] > data->bounds[1]) {
            data->Ts[i] = data->bounds[1];
        }
        data->logTs[i] = log(data->Ts[i]);
        data->invTs[i] = 1.0 / data->Ts[i];
	    data->dTs_{{ network.energy_term.name }}[i] = 1.0 / dge_dT;

    } // for i in nstrip loop
    return 0;
         
}
{% endblock %} {# calculate_temperature #}

{% block interpolate_rates %}
/*
   This setup may be different than the user may anticipate, as a result
   of the lockstep timestep we use for a pencil beam through the grid.
   As such, it accepts the number of things to interpolate and makes
   assumptions about the sizes of the rates.
*/

/* This also requires no templating other than for the solver name...*/
void {{ solver_name }}_interpolate_rates({{ solver_name }}_data *data,
                    int nstrip)
{
    int i, bin_id, zbin_id;
    double lb, t1, t2;
    double lbz, z1, z2, Tdef, zdef;
    int no_photo = 0;
    lb = log(data->bounds[0]);
    lbz = log(data->z_bounds[0] + 1.0);

    i = 0;

    for ( i = 0; i < nstrip; i++ ){
        data->bin_id[i] = bin_id = (int) (data->idbin * (data->logTs[i] - lb));
        if (data->bin_id[i] <= 0) {
            data->bin_id[i] = 0;
        } else if (data->bin_id[i] >= data->nbins) {
            data->bin_id[i] = data->nbins - 1;
        }
        t1 = (lb + (bin_id    ) * data->dbin);
        t2 = (lb + (bin_id + 1) * data->dbin);
        data->Tdef[i] = (data->logTs[i] - t1)/(t2 - t1);
        data->dT[i] = (t2 - t1);
        /*fprintf(stderr, "INTERP: %d, bin_id = %d, dT = % 0.16g, T = % 0.16g, logT = % 0.16g\n",
                i, data->bin_id[i], data->dT[i], data->Ts[i],
                data->logTs[i]);*/
    
    if ((data->current_z >= data->z_bounds[0]) && (data->current_z < data->z_bounds[1])) {
        zbin_id = (int) (data->id_zbin * (log(data->current_z + 1.0) - lbz));
        if (zbin_id <= 0) {
            zbin_id = 0;
        } else if (zbin_id >= data->n_zbins) {
            zbin_id = data->n_zbins - 1;
        }
        z1 = (lbz + (zbin_id    ) * data->d_zbin);
        z2 = (lbz + (zbin_id + 1) * data->d_zbin);
        data->zdef = (log(data->current_z + 1.0) - z1)/(z2 - z1);
        data->dz = (exp(z2) - exp(z1)); //note: given this, we don't have to divide rate of change by z
    } else {
        no_photo = 1;
    }
    }

    zdef   = data->zdef;
    
    {% for name, rate in network.reactions | dictsort %}
    {%- if 'pi' not in name %}
    
    for ( i = 0; i < nstrip; i++ ){
        bin_id = data->bin_id[i];
        Tdef   = data->Tdef[i];
        data->rs_{{name}}[i] = data->r_{{name}}[bin_id] +
            Tdef * (data->r_{{name}}[bin_id+1] - data->r_{{name}}[bin_id]);
        data->drs_{{name}}[i] = (data->r_{{name}}[bin_id+1] - data->r_{{name}}[bin_id]);
        data->drs_{{name}}[i] /= data->dT[i];
	    data->drs_{{name}}[i] *= data->invTs[i];

    }
    {% else %}
    for ( i = 0; i < nstrip; i++ ){
        if (no_photo) {
            data->rs_{{name}}[i] = 0.0;
            data->drs_{{name}}[i] = 0.0;
        } else {
        data->rs_{{name}}[i] = data->r_{{name}}[zbin_id] +
            zdef * (data->r_{{name}}[zbin_id+1] - data->r_{{name}}[zbin_id]);
        }
    }
    {% endif -%}
    {% endfor %}
    
    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    {%- if 'ph' not in name %}
    for ( i = 0; i < nstrip; i++ ){
        bin_id = data->bin_id[i];
        Tdef   = data->Tdef[i];
        data->cs_{{name}}_{{name2}}[i] = data->c_{{name}}_{{name2}}[bin_id] +
            Tdef * (data->c_{{name}}_{{name2}}[bin_id+1] - data->c_{{name}}_{{name2}}[bin_id]);
        data->dcs_{{name}}_{{name2}}[i] = (data->c_{{name}}_{{name2}}[bin_id+1] - data->c_{{name}}_{{name2}}[bin_id]);
        data->dcs_{{name}}_{{name2}}[i] /= data->dT[i];
	    data->dcs_{{name}}_{{name2}}[i] *= data->invTs[i];
    }
    {%- else %}
    for ( i = 0; i < nstrip; i++){
        if (no_photo) {
            data->cs_{{name}}_{{name2}}[i] = 0.0;
            data->dcs_{{name}}_{{name2}}[i] = 0.0;
        } else {
            data->cs_{{name}}_{{name2}}[i] = data->c_{{name}}_{{name2}}[zbin_id] +
                zdef * (data->c_{{name}}_{{name2}}[zbin_id+1] - data->c_{{name}}_{{name2}}[zbin_id]);
        }
    }
    {%- endif -%}          
    {% endfor %}
    {% endfor %}
    
}
{% endblock %} {# interpolate_rates #}

{% block interpolate_gamma %}
void {{ solver_name }}_interpolate_gamma({{ solver_name }}_data *data,
                    int i)
{   

    /*
     * find the bin_id for the given temperature 
     * update dT for i_th strip
     */

    int bin_id, zbin_id;
    double lb, t1, t2;
    double lbz, z1, z2;
    int no_photo = 0;
    lb = log(data->bounds[0]);
    lbz = log(data->z_bounds[0] + 1.0);
    
    data->bin_id[i] = bin_id = (int) (data->idbin * (data->logTs[i] - lb));
    if (data->bin_id[i] <= 0) {
        data->bin_id[i] = 0;
    } else if (data->bin_id[i] >= data->nbins) {
        data->bin_id[i] = data->nbins - 1;
    }
    t1 = (lb + (bin_id    ) * data->dbin);
    t2 = (lb + (bin_id + 1) * data->dbin);
    data->Tdef[i] = (data->logTs[i] - t1)/(t2 - t1);
    data->dT[i] = (t2 - t1);

    {% for sp in network.interpolate_gamma_species_name%}
    
    bin_id = data->bin_id[i];
    data->gamma{{sp}}[i] = data->g_gamma{{sp}}[bin_id] +
        data->Tdef[i] * (data->g_gamma{{sp}}[bin_id+1] - data->g_gamma{{sp}}[bin_id]);

    data->dgamma{{sp}}_dT[i] = data->g_dgamma{{sp}}_dT[bin_id] +
        data->Tdef[i] * (data->g_dgamma{{sp}}_dT[bin_id+1] 
        - data->g_dgamma{{sp}}_dT[bin_id]);
    {% endfor %}
       
    }

{% endblock interpolate_gamma%}


{% block ensure_electron_consistency %}

void ensure_electron_consistency(double *input, int nstrip, int nchem)
{
    int i, j;

    /* Now we set up some temporaries */
    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}
    double total_e = 0.0;
    int e_indx;
    
    double scale;

    for (i = 0; i<nstrip; i++) {
        j = i * nchem;
    {%- for species in network.required_species | sort %}
        {{species.name}} = input[j];
        {%if species.name != "ge" and species.name != "de" 
             and species.name != "us_e_0" %}
        total_e += {{species.name}} * {{species.free_electrons}};
        {%-endif%}
        {%if species.name == "de" or species.name == "us_e_0" -%}
        e_indx = j;
        {%endif%}
        j++;
    {% endfor %}
        input[e_indx] = total_e;
    }  
}

{% endblock %}

{% block temperature_from_mass_density %}
void temperature_from_mass_density(double *input, int nstrip,
                                   int nchem, double *strip_temperature)
{
    int i, j;
    double density;
    double kb = 1.3806504e-16; // Boltzmann constant [erg/K]
    double mh = 1.67e-24;
    double gamma = 5.e0/3.e0;
    double _gamma_m1 = 1.0 / (gamma - 1.0);
    {% if 'H2_1' in network.species_list() %}
    double gammaH2 = 7.e0/5.e0; // Should be a function of temperature
    	   	     		// this is a temporary solution
    
    double T =  1000.0; // THIS IS TEMPORARY!!! DELTETE!!

    {% endif %}
    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}
    
    double scale;

    for (i = 0; i<nstrip; i++) {
        j = i * nchem;
    {%- for species in network.required_species | sort %}
        {{species.name}} = input[j];
        {%if species.name != "ge" %}
        {{species.name}} /= {{species.weight}} * mh;
        {%endif%}
        /*fprintf(stderr, "{{species.name}}[%d] = % 0.16g\n",
                i, {{species.name}});*/
        j++;
    {% endfor %}
        density = {{network.print_mass_density()}};
        strip_temperature[i] = {{ network.temperature_calculation() }};
        if (strip_temperature[i] < 1.0)
            strip_temperature[i] = 1.0;
    }
         
}
{% endblock %} {# temperature_from_mass_density #}

{% block calculate_jacobian_sundials %}
int calculate_jacobian_{{solver_name}}( realtype t,
                                        N_Vector y, N_Vector fy,
                                        SUNMatrix J, void *user_data,
                                        N_Vector tmp1, N_Vector tmp2,
                                        N_Vector tmp3)
{
    /* We iterate over all of the rates */
    /* Calcuate temperature first */
    

    {{solver_name}}_data *data = ({{solver_name}}_data*)user_data; 
    
    int nchem = {{network.required_species | length }};
    int nstrip = data->nstrip;
    int i, j;

    /* change N_Vector back to an array */
    double y_arr[ {{network.required_species | length }} * nstrip ];
    double *scale     = data->scale;
    double *inv_scale = data->inv_scale;   
    
    /*
    for ( i = 0; i < nstrip; i++ ){
        j = i * nchem;
        {%- for species in network.required_species | sort %}
        y_arr[j] = NV_Ith_S( y, j )*scale[j];
        j++;
        {%- endfor %}
    }

    int flag;
    flag = {{solver_name}}_calculate_temperature(data, y_arr , nstrip, nchem );
    if (flag > 0){
        // check if the temperature failed to converged
        return -1;    
    }
    {{solver_name}}_interpolate_rates(data, nstrip);
    */

    // {{solver_name}}_calculate_temperature(data, y_arr, nstrip, nchem);
    // {{solver_name}}_interpolate_rates(data, nstrip);

    /* Now We set up some temporaries */

    double *T{{ network.energy_term.name }} = data->dTs_{{network.energy_term.name }};


    {%- for name, rate in network.reactions | dictsort %}
    double *{{name}} = data->rs_{{name}};
    double *r{{name}}= data->drs_{{name}};
    {%- endfor %}
    
    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    double *{{name}}_{{name2}} = data->cs_{{name}}_{{name2}};
    double *r{{name}}_{{name2}} = data->dcs_{{name}}_{{name2}};
    {%- endfor %}
    {%- endfor %}

    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}
    double z;
    double T;

    double mh = 1.67e-24;
    double mdensity, inv_mdensity;
    {% if "gloverabel08" in network.cooling_actions %}
    double h2_optical_depth_approx;  
    {% endif %}
    {% if "cie_cooling" in network.cooling_actions %}
    double cie_optical_depth_approx; 
    {% endif %}
  
    double scale1, inv_scale2;

    j = 0;
    mdensity = 0.0;
    z = data->current_z;

    for ( i = 0; i < nstrip; i++ ){
        j = i * nchem;
        {%- for species in network.required_species | sort %}
        {{species.name}} = NV_Ith_S( y, j )*scale[j];
        j++;
        {% endfor %}

        mdensity = data->mdensity[i];
        inv_mdensity = 1.0 / mdensity;
        {% if "gloverabel08" in network.cooling_actions %}
        h2_optical_depth_approx  = data->h2_optical_depth_approx[i];  
        {% endif %}
        {% if "cie_cooling" in network.cooling_actions %}
        cie_optical_depth_approx = data->cie_optical_depth_approx[i]; 
        {% endif %}

        j = i * nchem;
        {%- for s2 in network.required_species | sort %}
        //
        // Species: {{s2.name}}
        //
        {% set i_s2 = loop %}
        {%- for s1 in network.required_species | sort %}
        {% set i_s1 = loop%}
        // {{s2.name}} by {{s1.name}}
        {% if  network.print_jacobian_component(s2, s1, print_zeros = False) != None %}
        {{ network.print_jacobian_component(s2, s1, assign_to="SM_ELEMENT_D( J, j + {0}, j + {1} )".format( i_s2.index0, i_s1.index0 ) , print_zeros = False ) }}
        inv_scale2 = inv_scale[ j + {{i_s2.index0}}];
        scale1     = scale    [ j + {{i_s1.index0}}];
        SM_ELEMENT_D( J, j + {{i_s2.index0}}, j + {{i_s1.index0}}) *= inv_scale2*scale1;

        {% else %}
        // because the Jacobian is initialized to zeros by default
        // {{ network.print_jacobian_component(s2, s1, assign_to="SM_ELEMENT_D( J, j + {0}, j + {1} )".format( i_s2.index0, i_s1.index0 )  ) }}
        {% endif %}
        

        {% if s2.name == 'ge' and s1.name == 'ge'%}
        // ad-hoc extra term of f_ge by ge
        // considering ONLY the h2formation/ and continuum cooling
        SM_ELEMENT_D( J, j + {{i_s2.index0}}, j + {{i_s1.index0}} ) =  -H2_1*gloverabel08_h2lte[i]*h2_optical_depth_approx*(-gloverabel08_h2lte[i]*(-H2_1*rgloverabel08_gaH2[i] - H_1*rgloverabel08_gaHI[i] - H_2*rgloverabel08_gaHp[i] - He_1*rgloverabel08_gaHe[i] - de*rgloverabel08_gael[i])/pow(H2_1*gloverabel08_gaH2[i] + H_1*gloverabel08_gaHI[i] + H_2*gloverabel08_gaHp[i] + He_1*gloverabel08_gaHe[i] + de*gloverabel08_gael[i], 2) - rgloverabel08_h2lte[i]/(H2_1*gloverabel08_gaH2[i] + H_1*gloverabel08_gaHI[i] + H_2*gloverabel08_gaHp[i] + He_1*gloverabel08_gaHe[i] + de*gloverabel08_gael[i]))/pow(gloverabel08_h2lte[i]/(H2_1*gloverabel08_gaH2[i] + H_1*gloverabel08_gaHI[i] + H_2*gloverabel08_gaHp[i] + He_1*gloverabel08_gaHe[i] + de*gloverabel08_gael[i]) + 1.0, 2) - H2_1*h2_optical_depth_approx*rgloverabel08_h2lte[i]/(gloverabel08_h2lte[i]/(H2_1*gloverabel08_gaH2[i] + H_1*gloverabel08_gaHI[i] + H_2*gloverabel08_gaHp[i] + He_1*gloverabel08_gaHe[i] + de*gloverabel08_gael[i]) + 1.0) + 0.5*pow(h2formation_ncrn[i]/(H2_1*h2formation_ncrd2[i] + H_1*h2formation_ncrd1[i]) + 1.0, -2.0)*(-H2_1*H_1*h2formation_h2mcool[i] + pow(H_1, 3)*h2formation_h2mheat[i])*(-1.0*h2formation_ncrn[i]*(-H2_1*rh2formation_ncrd2[i] - H_1*rh2formation_ncrd1[i])/pow(H2_1*h2formation_ncrd2[i] + H_1*h2formation_ncrd1[i], 2) - 1.0*rh2formation_ncrn[i]/(H2_1*h2formation_ncrd2[i] + H_1*h2formation_ncrd1[i])) + 0.5*1.0/(h2formation_ncrn[i]/(H2_1*h2formation_ncrd2[i] + H_1*h2formation_ncrd1[i]) + 1.0)*(-H2_1*H_1*rh2formation_h2mcool[i] + pow(H_1, 3)*rh2formation_h2mheat[i]);
        {% endif %}

        {% if s2.name == 'ge' %}
        SM_ELEMENT_D( J, j + {{i_s2.index0}}, j + {{i_s1.index0}} ) *= inv_mdensity;
        {% endif %}
 	    
        {% if s1.name == 'ge' %}
        SM_ELEMENT_D( J, j + {{i_s2.index0}}, j + {{i_s1.index0}} ) *= T{{ network.energy_term.name }}[i];
        {% endif %}

        {%- endfor %}
        {% endfor %}
    }
    return 0;
}


{% endblock %}


{% block calcuate_rhs_sundials%}
int calculate_rhs_{{solver_name}}(realtype t, N_Vector y, N_Vector ydot, void *user_data)
{
    {{solver_name}}_data *data = ({{solver_name}}_data* ) user_data;
    int i, j;

    int nchem = {{network.required_species | length }};
    int nstrip = data->nstrip;
    
    /* change N_Vector back to an array */
    double y_arr[ {{network.required_species | length }} * nstrip ];
    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {% endfor %}
    
    double *scale     = data->scale;
    double *inv_scale = data->inv_scale;   
    
    for ( i = 0; i < nstrip; i++ ){
        j = i * nchem;
        {%- for species in network.required_species | sort %}
        y_arr[j] = NV_Ith_S( y, j )*scale[j];
        j++;
        {%- endfor %}
    }

    int flag;
    flag = {{solver_name}}_calculate_temperature(data, y_arr , nstrip, nchem );
    if (flag > 0){
        // check if the temperature failed to converged
        return -1;    
    }
    {{solver_name}}_interpolate_rates(data, nstrip);


    /* Now we set up some temporaries */
    
    {%- for name, rate in network.reactions | dictsort %}
    double *{{name}} = data->rs_{{name}};
    {%- endfor %}

    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    double *{{name}}_{{name2}} = data->cs_{{name}}_{{name2}};
    {%- endfor %}
    {%- endfor %}
    
    {% if "gloverabel08" in network.cooling_actions %}
    double h2_optical_depth_approx;    
    {% endif %}
    {% if "cie_cooling" in network.cooling_actions %}
    double cie_optical_depth_approx;
    {% endif %}

    double z;
    double T;

    double mh = 1.67e-24;
    double mdensity, inv_mdensity;

   
    for ( i = 0; i < nstrip; i++ ){
        
        T            = data->Ts[i];
        z            = data->current_z;
        mdensity     = data->mdensity[i];
        inv_mdensity = data->inv_mdensity[i];
        {% if "gloverabel" in network.cooling_actions %}
        h2_optical_depth_approx = data->h2_optical_depth_approx[i];
        {% endif %}
        {% if "cie_cooling" in network.cooling_actions %}
        cie_optical_depth_approx = data->cie_optical_depth_approx[i];
        {% endif %}

        j = i * nchem;
        {%- for species in network.required_species | sort %}
        {{species.name}} = y_arr[j];
        j++;
        {%- endfor %}
   
    
        j = i * nchem;
        {%- for species in network.required_species | sort %}
        //
        // Species: {{species.name}}
        //
        {{network.print_ccode(species, assign_to="NV_Ith_S( ydot, j )" ) }}
        NV_Ith_S( ydot, j ) *= inv_scale[j];
        {% if species.name == "ge" %}
        NV_Ith_S( ydot, j ) *= inv_mdensity;
        {% endif %}
        j++;
        //fprintf(stderr, "{{species.name}}: %0.5g\n", scale);
        //fprintf(stderr, "ydot = %0.5g \n", NV_Ith_S(ydot, {{loop.index0}}));
        {% endfor %}
    
    //fprintf(stderr, "----------------\n");
    }
    return 0;
    }
{% endblock %}

{% block solve_chemistry_dt %}

int {{solver_name}}_solve_chemistry_dt( dengo_field_data *field_data, 
{{solver_name}}_data *data, double dt ){
    
    int i, j;
    int N = {{network.required_species | length }};
    int dims = field_data->ncells; // total number of strips to be evaluated


    // turned the field data into a long chain of 
    // 1-D array
    //
    // N: number of species
    // d: d th number of strip to be evalulated
    // i: index for each species
    //    should be in correct order and handled 
    //    by dengo templates
    // i.e.
    // input[d*N + i] = field_data->HI_density[]
    //


    double *input = (double *) malloc(dims * N * sizeof(double));
    double *atol  = (double *) malloc(dims * N * sizeof(double));
    double *rtol  = (double *) malloc(dims * N * sizeof(double));
    double *temp  = (double *) malloc(dims * sizeof(double) );
    

    for ( int d = 0; d< dims; d++  ){
        j = d*N;
        // this should be the normalized 
        // by the input units later
        // atol = input * rtol;
        // which again should be set by dengo
        // input in *mass density per mH* 

        {%- for species in network.required_species | sort %}
        input[j] = field_data->{{species.name}}_density[d];
        atol[j] = input[j] * 1.0e-9;
        j++;
        {% endfor %}
    }

    double ttot;
    double z;
    double dtf = 1.0; 
    ttot = dengo_evolve_{{solver_name}}(dtf, dt, z, input, rtol, atol, dims, data, temp);
    
    int d;
    for ( d = 0; d< dims; d++  ){
        j = d*N;
        // this should be the normalized 
        // by the input units later
        // atol = input * rtol;
        // which again should be set by dengo
        
        {%- for species in network.required_species | sort %}
        field_data->{{species.name}}_density[d] = input[j];
        j++;
        {% endfor %}
    }


}


{% endblock %}

{% block read_init_data_to_dengo %}

int read_init_data_to_dengo( dengo_field_data *field_data ){

    // this reads the initial abundances of the data from
    // a hdf5 file, and initialize a field_data object

    char const *filename;
    filename = "newIC.h5";

    hid_t file_id = H5Fopen(filename, H5F_ACC_RDONLY, H5P_DEFAULT);

    if (file_id < 0){
        fprintf(stderr, "failed to open %s so dying. \n", filename);
        return (1);
        }

    hsize_t dims;


    /* Check gas energy to get the number of cells */
    fprintf(stderr, "Getting dimensionality from ge:\n");
    herr_t status = H5LTget_dataset_info(file_id, "/ge", &dims, NULL, NULL);
    if(status == -1) {
        fprintf(stderr, "Error opening initial conditions file.\n");
        return 1;
    }
    fprintf(stderr, "  ncells = % 3i\n", (int) dims);
    
    field_data->ncells = (int) dims;

    int N = {{network.required_species | length }};
    

    double *atol, *rtol;
    atol = (double *) malloc(N * dims * sizeof(double));
    rtol = (double *) malloc(N * dims * sizeof(double));

    double *tics = (double *) malloc(dims * sizeof(double));
    double *ics = (double *) malloc(dims * N * sizeof(double));
    double *input = (double *) malloc(dims * N * sizeof(double));
    
    unsigned int i = 0, j;

    {%- for species in network.required_species | sort %}
    double *{{species.name}} = (double *) malloc(dims * sizeof(double));    
    field_data->{{species.name}}_density = {{species.name}};
    {% endfor %}

    {%- for species in network.required_species | sort %}
    fprintf(stderr, "Reading I.C. for /{{species.name}}\n");
    H5LTread_dataset_double(file_id, "/{{species.name}}", tics);
    for ( j = 0; j < dims; j++ ){
        field_data->{{species.name}}_density[j] = tics[j];
        if (j == 0){
            fprintf(stderr, "{{species.name}}[0] = %0.3g \n", tics[j] );
        }
    }
    i++;
    {% endfor %}
    
    H5Fclose(file_id);
    free(input);
    free(atol);
    free(rtol);
    free(ics);
    
    return 1;

}
{% endblock %}



{% block calculate_JacTimesVec_sundials %}
int calculate_JacTimesVec_{{solver_name}}
            (N_Vector v, N_Vector Jv, realtype t,
             N_Vector y, N_Vector fy,
             void *user_data, N_Vector tmp)
{
    /* We iterate over all of the rates */
    /* Calcuate temperature first */ 
    int nstrip = 1;
    int nchem = {{network.required_species | length }};
    {{solver_name}}_data *data = ({{solver_name}}_data*)user_data; 
    

    int i, j;
    j = 0;

     /* change N_Vector back to an array */
    double y_arr[ {{network.required_species | length }} ];
    {%- for species in network.required_species | sort %}
    y_arr[{{loop.index - 1}}] = Ith(y , {{loop.index }});
    {%- endfor %}
    // Abundances are scaled in the calculate temperature module
    int flag;
    flag = {{solver_name}}_calculate_temperature(data, y_arr, nstrip, nchem);
    if (flag > 0){
        return 1;    
    }

    {{solver_name}}_interpolate_rates(data, nstrip);
    
    /* Now We set up some temporaries */
    double *T{{ network.energy_term.name }} = data->dTs_{{network.energy_term.name }};
    
    /* Define the reaction rates */
    {%- for name, rate in network.reactions | dictsort %}
    double *{{name}} = data->rs_{{name}};
    double *r{{name}} = data->drs_{{name}};
    {%- endfor %}

    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    double *{{name}}_{{name2}} = data->cs_{{name}}_{{name2}};
    double *r{{name}}_{{name2}} = data->dcs_{{name}}_{{name2}};
    {%- endfor %}
    {%- endfor %}
    
    {% if "gloverabel08" in network.cooling_actions %}
    double h2_optical_depth_approx;  
    {% endif %}

    double scale;
    /* Define the species */
    {%- for species in network.required_species | sort %}
    double {{species.name}}, v{{loop.index-1}};
    {%- endfor %}
    
    {%- for v in network.required_species | sort %}
    scale = data->scale[{{loop.index - 1}}];
    v{{loop.index-1}} = Ith( v, {{loop.index}} );
    v{{loop.index-1}} *= scale;
    {%- endfor %}

    double z;
    double T;

    double mh = 1.67e-24;
    double mdensity;
    
    int jj;
    jj = 0;

    j = i*nchem;
    mdensity = 0.0;
    z = data->current_z;
    {%- for species in network.required_species | sort %}
        // Rescale the Species abundance
    scale = data->scale[j];
    {{species.name}} = Ith( y, {{loop.index }}  )*scale;
    {%if species.name != "ge" and species.name != "de" and species.name != "us_e_0" %}
    mdensity += {{species.name}};
    {% endif %}
    j++;
    {% endfor %}


    mdensity *= mh;
        
    j = 0;
    {%- for s1 in network.required_species | sort %}
    //
    // Species: {{s1.name}}
    //
    {{ network.print_JacTimesVec_component(s1, assign_to="Ith(Jv, {0} )".format(loop.index) ) }}

    scale = data->scale[{{loop.index - 1}}];
    Ith(Jv, {{loop.index}}) /= scale;

    {% if s1.name == "ge" %}
    Ith(Jv, {{loop.index}}) /= mdensity;
    {% endif %}
    {%- endfor %}
    return 0;
}


{% endblock %}

{% block calculate_sparse_jacobian %}
#ifdef CVKLU
int calculate_sparse_jacobian_{{solver_name}}( realtype t,
                                        N_Vector y, N_Vector fy,
                                        SUNMatrix J, void *user_data,
                                        N_Vector tmp1, N_Vector tmp2,
                                        N_Vector tmp3)
{
    /* We iterate over all of the rates */
    /* Calcuate temperature first */
    

    {{solver_name}}_data *data = ({{solver_name}}_data*)user_data; 
    
    int nchem = {{network.required_species | length }};
    int nstrip = data->nstrip;
    int i, j;

    /* change N_Vector back to an array */
    double y_arr[ {{network.required_species | length }} * nstrip ];
    double *scale     = data->scale;
    double *inv_scale = data->inv_scale;   
    {% if "gloverabel08" in network.cooling_actions %}
    double h2_optical_depth_approx;  
    {% endif %}
    {% if "cie_cooling" in network.cooling_actions %}
    double cie_optical_depth_approx;
    {% endif %}

    /*
    for ( i = 0; i < nstrip; i++ ){
        j = i * nchem;
        {%- for species in network.required_species | sort %}
        y_arr[j] = NV_Ith_S( y, j )*scale[j];
        j++;
        {%- endfor %}
    }

    int flag;
    flag = {{solver_name}}_calculate_temperature(data, y_arr , nstrip, nchem );
    if (flag > 0){
        // check if the temperature failed to converged
        return -1;    
    }
    {{solver_name}}_interpolate_rates(data, nstrip);
    */

    // {{solver_name}}_calculate_temperature(data, y_arr, nstrip, nchem);
    // {{solver_name}}_interpolate_rates(data, nstrip);

    /* Now We set up some temporaries */
    
    // CSR is what we choose
    sunindextype *rowptrs = SUNSparseMatrix_IndexPointers(J);
    sunindextype *colvals = SUNSparseMatrix_IndexValues(J);
    realtype *matrix_data = SUNSparseMatrix_Data(J);
    
    SUNMatZero(J);
   
    double *T{{ network.energy_term.name }} = data->dTs_{{network.energy_term.name }};


    {%- for name, rate in network.reactions | dictsort %}
    double *{{name}} = data->rs_{{name}};
    double *r{{name}}= data->drs_{{name}};
    {%- endfor %}
    
    {%- for name, rate in network.cooling_actions | dictsort %}
    {%- for name2 in rate.tables | sort %}
    double *{{name}}_{{name2}} = data->cs_{{name}}_{{name2}};
    double *r{{name}}_{{name2}} = data->dcs_{{name}}_{{name2}};
    {%- endfor %}
    {%- endfor %}

    {%- for species in network.required_species | sort %}
    double {{species.name}};
    {%- endfor %}
    double z;
    double T;

    double mh = 1.67e-24;
    double mdensity, inv_mdensity;
    
    double scale2, inv_scale1;

    j = 0;
    mdensity = 0.0;
    z = data->current_z;
   
    int k = 0;
    for ( i = 0; i < nstrip; i++ ){
        j = i * nchem;
        {%- for species in network.required_species | sort %}
        {{species.name}} = NV_Ith_S( y, j )*scale[j];
        j++;
        {% endfor %}

        mdensity = data->mdensity[i];
        inv_mdensity = 1.0 / mdensity; 
        {% if "gloverabel08" in network.cooling_actions %}
        h2_optical_depth_approx = data->h2_optical_depth_approx[i];  
        {% endif %}
       
        j = i * 64;
        {% for colvals, jac_comp, s1, s2, k in network.get_sparse_matrix_component(sparse_type = "CSR", return_type="component", assign_to = "")%}
        // {{s1.name}} by {{s2.name}}
        colvals[j + {{k}}] = i * nchem + {{colvals}} ;
        matrix_data[ j + {{k}} ] {{jac_comp}}
        {% if s1.name == 'ge' and s2.name == 'ge'%}
        // ad-hoc extra term of ge by ge
        // considering ONLY the h2formation/ and continuum cooling
        matrix_data[ j + {{k}}] = -H2_1*gloverabel08_h2lte[i]*h2_optical_depth_approx*(-gloverabel08_h2lte[i]*(-H2_1*rgloverabel08_gaH2[i] - H_1*rgloverabel08_gaHI[i] - H_2*rgloverabel08_gaHp[i] - He_1*rgloverabel08_gaHe[i] - de*rgloverabel08_gael[i])/pow(H2_1*gloverabel08_gaH2[i] + H_1*gloverabel08_gaHI[i] + H_2*gloverabel08_gaHp[i] + He_1*gloverabel08_gaHe[i] + de*gloverabel08_gael[i], 2) - rgloverabel08_h2lte[i]/(H2_1*gloverabel08_gaH2[i] + H_1*gloverabel08_gaHI[i] + H_2*gloverabel08_gaHp[i] + He_1*gloverabel08_gaHe[i] + de*gloverabel08_gael[i]))/pow(gloverabel08_h2lte[i]/(H2_1*gloverabel08_gaH2[i] + H_1*gloverabel08_gaHI[i] + H_2*gloverabel08_gaHp[i] + He_1*gloverabel08_gaHe[i] + de*gloverabel08_gael[i]) + 1.0, 2) - H2_1*h2_optical_depth_approx*rgloverabel08_h2lte[i]/(gloverabel08_h2lte[i]/(H2_1*gloverabel08_gaH2[i] + H_1*gloverabel08_gaHI[i] + H_2*gloverabel08_gaHp[i] + He_1*gloverabel08_gaHe[i] + de*gloverabel08_gael[i]) + 1.0) + 0.5*pow(h2formation_ncrn[i]/(H2_1*h2formation_ncrd2[i] + H_1*h2formation_ncrd1[i]) + 1.0, -2.0)*(-H2_1*H_1*h2formation_h2mcool[i] + pow(H_1, 3)*h2formation_h2mheat[i])*(-1.0*h2formation_ncrn[i]*(-H2_1*rh2formation_ncrd2[i] - H_1*rh2formation_ncrd1[i])/pow(H2_1*h2formation_ncrd2[i] + H_1*h2formation_ncrd1[i], 2) - 1.0*rh2formation_ncrn[i]/(H2_1*h2formation_ncrd2[i] + H_1*h2formation_ncrd1[i])) + 0.5*1.0/(h2formation_ncrn[i]/(H2_1*h2formation_ncrd2[i] + H_1*h2formation_ncrd1[i]) + 1.0)*(-H2_1*H_1*rh2formation_h2mcool[i] + pow(H_1, 3)*rh2formation_h2mheat[i]);
        {% endif %}
        {% if s1.name == 'ge' %}
        matrix_data[j + {{k}}] *= inv_mdensity;
        {% endif %}
 	    {% if s2.name == 'ge' %}
        matrix_data[ j + {{k}}] *= T{{ network.energy_term.name }}[i];
        {% endif %}
        {% endfor %}
        
        {% for rowptrs in network.get_sparse_matrix_component(sparse_type = "CSR", return_type = "indexptrs") %}
        rowptrs[ i * nchem +  {{loop.index0}}] = i * 64 + {{rowptrs}};
        {% endfor %}
        
        j = i * nchem;
        {% for i1, i2, k in network.get_sparse_matrix_component(sparse_type = "CSR", return_type="index")%}
        inv_scale1 = inv_scale[ j + {{i1}} ];
        scale2     = scale    [ j + {{i2}} ];
        matrix_data[ i * 64 + {{k}}]  *= inv_scale1*scale2; 
        {% endfor %}


    }

    rowptrs[ i * nchem ] = i * 64 ;
    return 0;
}

#endif
{% endblock %}


{% block setting_up_extra_variables %}
void setting_up_extra_variables( {{solver_name}}_data * data, double * input, int nstrip ){
    
    int i, j;
    double mh = 1.67e-24;
    for ( i = 0; i < nstrip; i++){
        data->mdensity[i] = 0;
        j = i * {{network.required_species | length}};
        {%- for species in network.required_species | sort %}
        {%if species.name not in ["ge", "de"] %}
        // species: {{species.name}}
        data->mdensity[i] += input[j] * {{species.weight}}; 
        {%endif%}
        j ++;
        {%endfor%}
        data->mdensity[i] *= mh;
        data->inv_mdensity[i] = 1.0 / data->mdensity[i];
    }

    {% if "cie_cooling" in network.cooling_actions %}
    double mdensity, tau;
    for ( i = 0; i < nstrip; i++){
        
        mdensity = data->mdensity[i];
        tau      = pow( (mdensity / 3.3e-8 ), 2.8);
        tau      = fmax( tau, 1.0e-5 );
        data->cie_optical_depth_approx[i] = 
            fmin( 1.0, (1.0 - exp(-tau) ) / tau );
    }
    {% endif %}


    {% if "gloverabel08" in network.cooling_actions %}
    for ( i = 0; i < nstrip; i++ ){
        mdensity = data->mdensity[i];
        data->h2_optical_depth_approx[i] =  fmin( 1.0, pow( (mdensity / (1.34e-14) )  , -0.45) );
    }
    {% endif %}


}
{% endblock %}
